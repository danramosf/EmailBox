<!DOCTYPE html>
<html>
<head>
  <title>README.md</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="../../doc-style.css" />
  <script src="../../doc-filelist.js"></script>
  <script>
    var relativeDir = "../../";
    var thisFile = "node_modules\\graphql-subscriptions\\README.md";
    var defaultSidebar = true;
  </script>
  <script src="../../doc-script.js"></script>

</head>
<body>
  <div id="sidebar_wrapper">
    <div id="sidebar_switch">
      <span class="tree">Files</span>
      <span class="headings">Headings</span>
    </div>
    <div id="tree"></div>
    <div id="headings">

      <div class="heading h1">
        <a href="#graphql-subscriptions">graphql-subscriptions</a>
      </div>

      <div class="heading h3">
        <a href="#installation">Installation</a>
      </div>

      <div class="heading h3">
        <a href="#typescript">TypeScript</a>
      </div>

      <div class="heading h3">
        <a href="#getting-started-with-your-first-subscription">Getting started with your first subscription</a>
      </div>

      <div class="heading h3">
        <a href="#filters">Filters</a>
      </div>

      <div class="heading h3">
        <a href="#channels-mapping">Channels Mapping</a>
      </div>

      <div class="heading h3">
        <a href="#payload-manipulation">Payload Manipulation</a>
      </div>

      <div class="heading h3">
        <a href="#custom-asynciterator-wrappers">Custom AsyncIterator Wrappers</a>
      </div>

      <div class="heading h3">
        <a href="#pubsub-implementations">PubSub Implementations</a>
      </div>

      <div class="heading h4">
        <a href="#subscriptionmanager-@deprecated">SubscriptionManager @deprecated</a>
      </div>

    </div>
  </div>
  <div id="sidebar-toggle"></div>
  <div id="container">
    <div class="docs markdown"><p><a href="https://badge.fury.io/js/graphql-subscriptions"><img src="https://badge.fury.io/js/graphql-subscriptions.svg" alt="npm version"></a> <a href="https://github.com/apollostack/graphql-subscriptions/blob/license/LICENSE"><img src="https://img.shields.io/github/license/apollostack/graphql-subscriptions.svg" alt="GitHub license"></a></p>
<div class="pilwrap" id="graphql-subscriptions">
  <h1>
    <a href="#graphql-subscriptions" name="graphql-subscriptions" class="pilcrow"></a>
graphql-subscriptions
  </h1>
</div>
<p>GraphQL subscriptions is a simple npm package that lets you wire up GraphQL with a pubsub system (like Redis) to implement subscriptions in GraphQL.</p>
<p>You can use it with any GraphQL client and server (not only Apollo).</p>
<div class="pilwrap" id="installation">
  <h3>
    <a href="#installation" name="installation" class="pilcrow"></a>
Installation
  </h3>
</div>
<p><code>npm install graphql-subscriptions graphql</code> or <code>yarn add graphql-subscriptions graphql</code></p>
<blockquote>
<p>This package should be used with a network transport, for example <a href="https://github.com/apollographql/subscriptions-transport-ws">subscriptions-transport-ws</a>.</p>
</blockquote>
<div class="pilwrap" id="typescript">
  <h3>
    <a href="#typescript" name="typescript" class="pilcrow"></a>
TypeScript
  </h3>
</div>
<p>If you are developing a project that uses this module with TypeScript:</p>
<ul>
<li>ensure that your <code>tsconfig.json</code> <code>lib</code> definition includes <code>&quot;esnext.asynciterable&quot;</code></li>
<li><code>npm install @types/graphql</code> or <code>yarn add @types/graphql</code></li>
</ul>
<div class="pilwrap" id="getting-started-with-your-first-subscription">
  <h3>
    <a href="#getting-started-with-your-first-subscription" name="getting-started-with-your-first-subscription" class="pilcrow"></a>
Getting started with your first subscription
  </h3>
</div>
<p>To begin with GraphQL subscriptions, start by defining a GraphQL <code>Subscription</code> type in your schema:</p>
<pre><code class="graphql">type Subscription {
    somethingChanged: Result
}

type Result {
    id: String
}
</code></pre>
<p>Next, add the <code>Subscription</code> type to your <code>schema</code> definition:</p>
<pre><code class="graphql">schema {
  query: Query
  mutation: Mutation
  subscription: Subscription
}
</code></pre>
<p>Now, let's create a simple <code>PubSub</code> instance - it is a simple pubsub implementation, based on <code>EventEmitter</code>. Alternative <code>EventEmitter</code> implementations can be passed by an options object
to the <code>PubSub</code> constructor.</p>
<pre><code class="js"><span class="hljs-keyword">import</span> { PubSub } <span class="hljs-keyword">from</span> <span class="hljs-string">'graphql-subscriptions'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> pubsub = <span class="hljs-keyword">new</span> PubSub();
</code></pre>
<p>Now, implement your Subscriptions type resolver, using the <code>pubsub.asyncIterator</code> to map the event you need:</p>
<pre><code class="js"><span class="hljs-keyword">const</span> SOMETHING_CHANGED_TOPIC = <span class="hljs-string">'something_changed'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> resolvers = {
  <span class="hljs-attr">Subscription</span>: {
    <span class="hljs-attr">somethingChanged</span>: {
      <span class="hljs-attr">subscribe</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> pubsub.asyncIterator(SOMETHING_CHANGED_TOPIC),
    },
  },
}
</code></pre>
<blockquote>
<p>Subscriptions resolvers are not a function, but an object with <code>subscribe</code> method, than returns <code>AsyncIterable</code>.</p>
</blockquote>
<p>Now, GraphQL engine knows that <code>somethingChanged</code> is a subscription, and every time we will use <code>pubsub.publish</code> over this topic - is will publish it using the transport we use:</p>
<pre><code class="js">pubsub.publish(SOMETHING_CHANGED_TOPIC, { <span class="hljs-attr">somethingChanged</span>: { <span class="hljs-attr">id</span>: <span class="hljs-string">"123"</span> }});
</code></pre>
<blockquote>
<p>Note that the default PubSub implementation is intended for demo purposes. It only works if you have a single instance of your server and doesn't scale beyond a couple of connections.
For production usage you'll want to use one of the <a href="#pubsub-implementations.html">PubSub implementations</a> backed by an external store. (e.g. Redis)</p>
</blockquote>
<div class="pilwrap" id="filters">
  <h3>
    <a href="#filters" name="filters" class="pilcrow"></a>
Filters
  </h3>
</div>
<p>When publishing data to subscribers, we need to make sure that each subscribers get only the data it need.</p>
<p>To do so, we can use <code>withFilter</code> helper from this package, which wraps <code>AsyncIterator</code> with a filter function, and let you control each publication for each user.</p>
<p><code>withFilter</code> API:</p>
<ul>
<li><code>asyncIteratorFn: (rootValue, args, context, info) =&gt; AsyncIterator&lt;any&gt;</code> : A function that returns <code>AsyncIterator</code> you got from your <code>pubsub.asyncIterator</code>.</li>
<li><code>filterFn: (payload, variables, context, info) =&gt; boolean | Promise&lt;boolean&gt;</code> - A filter function, executed with the payload (the published value), variables, context and operation info, must return <code>boolean</code> or <code>Promise&lt;boolean&gt;</code> indicating if the payload should pass to the subscriber.</li>
</ul>
<p>For example, if <code>somethingChanged</code> would also accept a variable with the ID that is relevant, we can use the following code to filter according to it:</p>
<pre><code class="js"><span class="hljs-keyword">import</span> { withFilter } <span class="hljs-keyword">from</span> <span class="hljs-string">'graphql-subscriptions'</span>;

<span class="hljs-keyword">const</span> SOMETHING_CHANGED_TOPIC = <span class="hljs-string">'something_changed'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> resolvers = {
  <span class="hljs-attr">Subscription</span>: {
    <span class="hljs-attr">somethingChanged</span>: {
      <span class="hljs-attr">subscribe</span>: withFilter(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> pubsub.asyncIterator(SOMETHING_CHANGED_TOPIC), (payload, variables) =&gt; {
        <span class="hljs-keyword">return</span> payload.somethingChanged.id === variables.relevantId;
      }),
    },
  },
}
</code></pre>
<blockquote>
<p>Note that when using <code>withFilter</code>, you don't need to wrap your return value with a function.</p>
</blockquote>
<div class="pilwrap" id="channels-mapping">
  <h3>
    <a href="#channels-mapping" name="channels-mapping" class="pilcrow"></a>
Channels Mapping
  </h3>
</div>
<p>You can map multiple channels into the same subscription, for example when there are multiple events that trigger the same subscription in the GraphQL engine.</p>
<pre><code class="js"><span class="hljs-keyword">const</span> SOMETHING_UPDATED = <span class="hljs-string">'something_updated'</span>;
<span class="hljs-keyword">const</span> SOMETHING_CREATED = <span class="hljs-string">'something_created'</span>;
<span class="hljs-keyword">const</span> SOMETHING_REMOVED = <span class="hljs-string">'something_removed'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> resolvers = {
  <span class="hljs-attr">Subscription</span>: {
    <span class="hljs-attr">somethingChanged</span>: {
      <span class="hljs-attr">subscribe</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> pubsub.asyncIterator([ SOMETHING_UPDATED, SOMETHING_CREATED, SOMETHING_REMOVED ]),
    },
  },
}
</code></pre>
<div class="pilwrap" id="payload-manipulation">
  <h3>
    <a href="#payload-manipulation" name="payload-manipulation" class="pilcrow"></a>
Payload Manipulation
  </h3>
</div>
<p>You can also manipulate the published payload, by adding <code>resolve</code> methods to your subscription:</p>
<pre><code class="js"><span class="hljs-keyword">const</span> SOMETHING_UPDATED = <span class="hljs-string">'something_updated'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> resolvers = {
  <span class="hljs-attr">Subscription</span>: {
    <span class="hljs-attr">somethingChanged</span>: {
      <span class="hljs-attr">resolve</span>: <span class="hljs-function">(<span class="hljs-params">payload, args, context, info</span>) =&gt;</span> {
        <span class="hljs-comment">// Manipulate and return the new value</span>

        <span class="hljs-keyword">return</span> payload;
      },
      <span class="hljs-attr">subscribe</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> pubsub.asyncIterator(SOMETHING_UPDATED),
    },
  },
}
</code></pre>
<div class="pilwrap" id="custom-asynciterator-wrappers">
  <h3>
    <a href="#custom-asynciterator-wrappers" name="custom-asynciterator-wrappers" class="pilcrow"></a>
Custom <code>AsyncIterator</code> Wrappers
  </h3>
</div>
<p>The value you should return from your <code>subscribe</code> resolver must be an <code>AsyncIterator</code>.</p>
<p>You can use this value and wrap it with another <code>AsyncIterator</code> to implement custom logic over your subscriptions.</p>
<p>For example, the following implementation manipulate the payload by adding some static fields:</p>
<pre><code class="typescript"><span class="hljs-keyword">import</span> { $$asyncIterator } <span class="hljs-keyword">from</span> <span class="hljs-string">'iterall'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> withStaticFields = (asyncIterator: AsyncIterator&lt;<span class="hljs-built_in">any</span>&gt;, staticFields: <span class="hljs-built_in">Object</span>): <span class="hljs-function"><span class="hljs-params">Function</span> =&gt;</span> {
  <span class="hljs-keyword">return</span> (rootValue: <span class="hljs-built_in">any</span>, args: <span class="hljs-built_in">any</span>, context: <span class="hljs-built_in">any</span>, info: <span class="hljs-built_in">any</span>): AsyncIterator&lt;<span class="hljs-built_in">any</span>&gt; =&gt; {

    <span class="hljs-keyword">return</span> {
      next() {
        <span class="hljs-keyword">return</span> asyncIterator.next().then(<span class="hljs-function">(<span class="hljs-params">{ value, done }</span>) =&gt;</span> {
          <span class="hljs-keyword">return</span> {
            value: {
              ...value,
              ...staticFields,
            },
            done,
          };
        });
      },
      <span class="hljs-keyword">return</span>() {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve({ value: <span class="hljs-literal">undefined</span>, done: <span class="hljs-literal">true</span> });
      },
      <span class="hljs-keyword">throw</span>(error) {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(error);
      },
      [$$asyncIterator]() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
      },
    };
  };
};
</code></pre>
<blockquote>
<p>You can also take a look at <code>withFilter</code> for inspiration.</p>
</blockquote>
<p>For more information about <code>AsyncIterator</code>:</p>
<ul>
<li><a href="https://github.com/tc39/proposal-async-iteration">TC39 Proposal</a></li>
<li><a href="https://github.com/leebyron/iterall">iterall</a></li>
<li><a href="https://github.com/ReactiveX/IxJS">IxJS</a></li>
</ul>
<div class="pilwrap" id="pubsub-implementations">
  <h3>
    <a href="#pubsub-implementations" name="pubsub-implementations" class="pilcrow"></a>
PubSub Implementations
  </h3>
</div>
<p>It can be easily replaced with some other implementations of <a href="https://github.com/apollographql/graphql-subscriptions/blob/master/src/pubsub.ts#L21-L25">PubSubEngine interface</a>. There are a couple of them out there:</p>
<ul>
<li>Use Redis with https://github.com/davidyaha/graphql-redis-subscriptions</li>
<li>Use MQTT enabled broker with https://github.com/davidyaha/graphql-mqtt-subscriptions</li>
<li>Use RabbitMQ with https://github.com/cdmbase/graphql-rabbitmq-subscriptions</li>
<li>Use Kafka with https://github.com/ancashoria/graphql-kafka-subscriptions</li>
<li><a href="https://github.com/apollographql/graphql-subscriptions/pull/new/master">Add your implementation...</a></li>
</ul>
<p>You can also implement a <code>PubSub</code> of your own, by using the exported interface <code>PubSubEngine</code> from this package.</p>
<div class="pilwrap" id="subscriptionmanager-@deprecated">
  <h4>
    <a href="#subscriptionmanager-@deprecated" name="subscriptionmanager-@deprecated" class="pilcrow"></a>
SubscriptionManager <strong>@deprecated</strong>
  </h4>
</div>
<p><code>SubscriptionManager</code> is the previous alternative for using <code>graphql-js</code> subscriptions directly, and it's now deprecated.</p>
<p>If you are looking for it's API docs, refer to <a href="https://github.com/apollographql/graphql-subscriptions/blob/5eaee92cd50060b3f3637f00c53960f51a07d0b2/README.md">a previous commit of the repository</a></p>
</div>
  </div>
</body>
</html>
