<!DOCTYPE html>
<html>
<head>
  <title>README.md</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="../../doc-style.css" />
  <script src="../../doc-filelist.js"></script>
  <script>
    var relativeDir = "../../";
    var thisFile = "node_modules\\qs\\README.md";
    var defaultSidebar = true;
  </script>
  <script src="../../doc-script.js"></script>

</head>
<body>
  <div id="sidebar_wrapper">
    <div id="sidebar_switch">
      <span class="tree">Files</span>
      <span class="headings">Headings</span>
    </div>
    <div id="tree"></div>
    <div id="headings">

      <div class="heading h1">
        <a href="#qs">qs </a>
      </div>

      <div class="heading h2">
        <a href="#usage">Usage</a>
      </div>

      <div class="heading h3">
        <a href="#parsing-objects">Parsing Objects</a>
      </div>

      <div class="heading h3">
        <a href="#parsing-arrays">Parsing Arrays</a>
      </div>

      <div class="heading h3">
        <a href="#stringifying">Stringifying</a>
      </div>

      <div class="heading h3">
        <a href="#handling-of-null-values">Handling of null values</a>
      </div>

      <div class="heading h3">
        <a href="#dealing-with-special-character-sets">Dealing with special character sets</a>
      </div>

      <div class="heading h3">
        <a href="#rfc-3986-and-rfc-1738-space-encoding">RFC 3986 and RFC 1738 space encoding</a>
      </div>

    </div>
  </div>
  <div id="sidebar-toggle"></div>
  <div id="container">
    <div class="docs markdown"><div class="pilwrap" id="qs">
  <h1>
    <a href="#qs" name="qs" class="pilcrow"></a>
qs <sup><a href="https://npmjs.org/package/qs"><img src="http://versionbadg.es/ljharb/qs.svg" alt="Version Badge"></a></sup>
  </h1>
</div>
<p><a href="https://travis-ci.org/ljharb/qs"><img src="https://api.travis-ci.org/ljharb/qs.svg" alt="Build Status"></a>
<a href="https://david-dm.org/ljharb/qs"><img src="https://david-dm.org/ljharb/qs.svg" alt="dependency status"></a>
<a href="https://david-dm.org/ljharb/qs?type=dev"><img src="https://david-dm.org/ljharb/qs/dev-status.svg" alt="dev dependency status"></a>
<a href="LICENSE.html"><img src="http://img.shields.io/npm/l/qs.svg" alt="License"></a>
<a href="http://npm-stat.com/charts.html?package=qs"><img src="http://img.shields.io/npm/dm/qs.svg" alt="Downloads"></a></p>
<p><a href="https://npmjs.org/package/qs"><img src="https://nodei.co/npm/qs.png?downloads=true&amp;stars=true" alt="npm badge"></a></p>
<p>A querystring parsing and stringifying library with some added security.</p>
<p>Lead Maintainer: <a href="https://github.com/ljharb">Jordan Harband</a></p>
<p>The <strong>qs</strong> module was originally created and maintained by <a href="https://github.com/visionmedia/node-querystring">TJ Holowaychuk</a>.</p>
<div class="pilwrap" id="usage">
  <h2>
    <a href="#usage" name="usage" class="pilcrow"></a>
Usage
  </h2>
</div>
<pre><code class="javascript"><span class="hljs-keyword">var</span> qs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'qs'</span>);
<span class="hljs-keyword">var</span> assert = <span class="hljs-built_in">require</span>(<span class="hljs-string">'assert'</span>);

<span class="hljs-keyword">var</span> obj = qs.parse(<span class="hljs-string">'a=c'</span>);
assert.deepEqual(obj, { <span class="hljs-attr">a</span>: <span class="hljs-string">'c'</span> });

<span class="hljs-keyword">var</span> str = qs.stringify(obj);
assert.equal(str, <span class="hljs-string">'a=c'</span>);
</code></pre>
<div class="pilwrap" id="parsing-objects">
  <h3>
    <a href="#parsing-objects" name="parsing-objects" class="pilcrow"></a>
Parsing Objects
  </h3>
</div>
<p><a href="#preventEval.html"></a></p>
<pre><code class="javascript">qs.parse(string, [options]);
</code></pre>
<p><strong>qs</strong> allows you to create nested objects within your query strings, by surrounding the name of sub-keys with square brackets <code>[]</code>.
For example, the string <code>'foo[bar]=baz'</code> converts to:</p>
<pre><code class="javascript">assert.deepEqual(qs.parse(<span class="hljs-string">'foo[bar]=baz'</span>), {
    <span class="hljs-attr">foo</span>: {
        <span class="hljs-attr">bar</span>: <span class="hljs-string">'baz'</span>
    }
});
</code></pre>
<p>When using the <code>plainObjects</code> option the parsed value is returned as a null object, created via <code>Object.create(null)</code> and as such you should be aware that prototype methods will not exist on it and a user may set those names to whatever value they like:</p>
<pre><code class="javascript"><span class="hljs-keyword">var</span> nullObject = qs.parse(<span class="hljs-string">'a[hasOwnProperty]=b'</span>, { <span class="hljs-attr">plainObjects</span>: <span class="hljs-literal">true</span> });
assert.deepEqual(nullObject, { <span class="hljs-attr">a</span>: { <span class="hljs-attr">hasOwnProperty</span>: <span class="hljs-string">'b'</span> } });
</code></pre>
<p>By default parameters that would overwrite properties on the object prototype are ignored, if you wish to keep the data from those fields either use <code>plainObjects</code> as mentioned above, or set <code>allowPrototypes</code> to <code>true</code> which will allow user input to overwrite those properties. <em>WARNING</em> It is generally a bad idea to enable this option as it can cause problems when attempting to use the properties that have been overwritten. Always be careful with this option.</p>
<pre><code class="javascript"><span class="hljs-keyword">var</span> protoObject = qs.parse(<span class="hljs-string">'a[hasOwnProperty]=b'</span>, { <span class="hljs-attr">allowPrototypes</span>: <span class="hljs-literal">true</span> });
assert.deepEqual(protoObject, { <span class="hljs-attr">a</span>: { <span class="hljs-attr">hasOwnProperty</span>: <span class="hljs-string">'b'</span> } });
</code></pre>
<p>URI encoded strings work too:</p>
<pre><code class="javascript">assert.deepEqual(qs.parse(<span class="hljs-string">'a%5Bb%5D=c'</span>), {
    <span class="hljs-attr">a</span>: { <span class="hljs-attr">b</span>: <span class="hljs-string">'c'</span> }
});
</code></pre>
<p>You can also nest your objects, like <code>'foo[bar][baz]=foobarbaz'</code>:</p>
<pre><code class="javascript">assert.deepEqual(qs.parse(<span class="hljs-string">'foo[bar][baz]=foobarbaz'</span>), {
    <span class="hljs-attr">foo</span>: {
        <span class="hljs-attr">bar</span>: {
            <span class="hljs-attr">baz</span>: <span class="hljs-string">'foobarbaz'</span>
        }
    }
});
</code></pre>
<p>By default, when nesting objects <strong>qs</strong> will only parse up to 5 children deep. This means if you attempt to parse a string like
<code>'a[b][c][d][e][f][g][h][i]=j'</code> your resulting object will be:</p>
<pre><code class="javascript"><span class="hljs-keyword">var</span> expected = {
    <span class="hljs-attr">a</span>: {
        <span class="hljs-attr">b</span>: {
            <span class="hljs-attr">c</span>: {
                <span class="hljs-attr">d</span>: {
                    <span class="hljs-attr">e</span>: {
                        <span class="hljs-attr">f</span>: {
                            <span class="hljs-string">'[g][h][i]'</span>: <span class="hljs-string">'j'</span>
                        }
                    }
                }
            }
        }
    }
};
<span class="hljs-keyword">var</span> string = <span class="hljs-string">'a[b][c][d][e][f][g][h][i]=j'</span>;
assert.deepEqual(qs.parse(string), expected);
</code></pre>
<p>This depth can be overridden by passing a <code>depth</code> option to <code>qs.parse(string, [options])</code>:</p>
<pre><code class="javascript"><span class="hljs-keyword">var</span> deep = qs.parse(<span class="hljs-string">'a[b][c][d][e][f][g][h][i]=j'</span>, { <span class="hljs-attr">depth</span>: <span class="hljs-number">1</span> });
assert.deepEqual(deep, { <span class="hljs-attr">a</span>: { <span class="hljs-attr">b</span>: { <span class="hljs-string">'[c][d][e][f][g][h][i]'</span>: <span class="hljs-string">'j'</span> } } });
</code></pre>
<p>The depth limit helps mitigate abuse when <strong>qs</strong> is used to parse user input, and it is recommended to keep it a reasonably small number.</p>
<p>For similar reasons, by default <strong>qs</strong> will only parse up to 1000 parameters. This can be overridden by passing a <code>parameterLimit</code> option:</p>
<pre><code class="javascript"><span class="hljs-keyword">var</span> limited = qs.parse(<span class="hljs-string">'a=b&amp;c=d'</span>, { <span class="hljs-attr">parameterLimit</span>: <span class="hljs-number">1</span> });
assert.deepEqual(limited, { <span class="hljs-attr">a</span>: <span class="hljs-string">'b'</span> });
</code></pre>
<p>To bypass the leading question mark, use <code>ignoreQueryPrefix</code>:</p>
<pre><code class="javascript"><span class="hljs-keyword">var</span> prefixed = qs.parse(<span class="hljs-string">'?a=b&amp;c=d'</span>, { <span class="hljs-attr">ignoreQueryPrefix</span>: <span class="hljs-literal">true</span> });
assert.deepEqual(prefixed, { <span class="hljs-attr">a</span>: <span class="hljs-string">'b'</span>, <span class="hljs-attr">c</span>: <span class="hljs-string">'d'</span> });
</code></pre>
<p>An optional delimiter can also be passed:</p>
<pre><code class="javascript"><span class="hljs-keyword">var</span> delimited = qs.parse(<span class="hljs-string">'a=b;c=d'</span>, { <span class="hljs-attr">delimiter</span>: <span class="hljs-string">';'</span> });
assert.deepEqual(delimited, { <span class="hljs-attr">a</span>: <span class="hljs-string">'b'</span>, <span class="hljs-attr">c</span>: <span class="hljs-string">'d'</span> });
</code></pre>
<p>Delimiters can be a regular expression too:</p>
<pre><code class="javascript"><span class="hljs-keyword">var</span> regexed = qs.parse(<span class="hljs-string">'a=b;c=d,e=f'</span>, { <span class="hljs-attr">delimiter</span>: <span class="hljs-regexp">/[;,]/</span> });
assert.deepEqual(regexed, { <span class="hljs-attr">a</span>: <span class="hljs-string">'b'</span>, <span class="hljs-attr">c</span>: <span class="hljs-string">'d'</span>, <span class="hljs-attr">e</span>: <span class="hljs-string">'f'</span> });
</code></pre>
<p>Option <code>allowDots</code> can be used to enable dot notation:</p>
<pre><code class="javascript"><span class="hljs-keyword">var</span> withDots = qs.parse(<span class="hljs-string">'a.b=c'</span>, { <span class="hljs-attr">allowDots</span>: <span class="hljs-literal">true</span> });
assert.deepEqual(withDots, { <span class="hljs-attr">a</span>: { <span class="hljs-attr">b</span>: <span class="hljs-string">'c'</span> } });
</code></pre>
<div class="pilwrap" id="parsing-arrays">
  <h3>
    <a href="#parsing-arrays" name="parsing-arrays" class="pilcrow"></a>
Parsing Arrays
  </h3>
</div>
<p><strong>qs</strong> can also parse arrays using a similar <code>[]</code> notation:</p>
<pre><code class="javascript"><span class="hljs-keyword">var</span> withArray = qs.parse(<span class="hljs-string">'a[]=b&amp;a[]=c'</span>);
assert.deepEqual(withArray, { <span class="hljs-attr">a</span>: [<span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>] });
</code></pre>
<p>You may specify an index as well:</p>
<pre><code class="javascript"><span class="hljs-keyword">var</span> withIndexes = qs.parse(<span class="hljs-string">'a[1]=c&amp;a[0]=b'</span>);
assert.deepEqual(withIndexes, { <span class="hljs-attr">a</span>: [<span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>] });
</code></pre>
<p>Note that the only difference between an index in an array and a key in an object is that the value between the brackets must be a number
to create an array. When creating arrays with specific indices, <strong>qs</strong> will compact a sparse array to only the existing values preserving
their order:</p>
<pre><code class="javascript"><span class="hljs-keyword">var</span> noSparse = qs.parse(<span class="hljs-string">'a[1]=b&amp;a[15]=c'</span>);
assert.deepEqual(noSparse, { <span class="hljs-attr">a</span>: [<span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>] });
</code></pre>
<p>Note that an empty string is also a value, and will be preserved:</p>
<pre><code class="javascript"><span class="hljs-keyword">var</span> withEmptyString = qs.parse(<span class="hljs-string">'a[]=&amp;a[]=b'</span>);
assert.deepEqual(withEmptyString, { <span class="hljs-attr">a</span>: [<span class="hljs-string">''</span>, <span class="hljs-string">'b'</span>] });

<span class="hljs-keyword">var</span> withIndexedEmptyString = qs.parse(<span class="hljs-string">'a[0]=b&amp;a[1]=&amp;a[2]=c'</span>);
assert.deepEqual(withIndexedEmptyString, { <span class="hljs-attr">a</span>: [<span class="hljs-string">'b'</span>, <span class="hljs-string">''</span>, <span class="hljs-string">'c'</span>] });
</code></pre>
<p><strong>qs</strong> will also limit specifying indices in an array to a maximum index of <code>20</code>. Any array members with an index of greater than <code>20</code> will
instead be converted to an object with the index as the key:</p>
<pre><code class="javascript"><span class="hljs-keyword">var</span> withMaxIndex = qs.parse(<span class="hljs-string">'a[100]=b'</span>);
assert.deepEqual(withMaxIndex, { <span class="hljs-attr">a</span>: { <span class="hljs-string">'100'</span>: <span class="hljs-string">'b'</span> } });
</code></pre>
<p>This limit can be overridden by passing an <code>arrayLimit</code> option:</p>
<pre><code class="javascript"><span class="hljs-keyword">var</span> withArrayLimit = qs.parse(<span class="hljs-string">'a[1]=b'</span>, { <span class="hljs-attr">arrayLimit</span>: <span class="hljs-number">0</span> });
assert.deepEqual(withArrayLimit, { <span class="hljs-attr">a</span>: { <span class="hljs-string">'1'</span>: <span class="hljs-string">'b'</span> } });
</code></pre>
<p>To disable array parsing entirely, set <code>parseArrays</code> to <code>false</code>.</p>
<pre><code class="javascript"><span class="hljs-keyword">var</span> noParsingArrays = qs.parse(<span class="hljs-string">'a[]=b'</span>, { <span class="hljs-attr">parseArrays</span>: <span class="hljs-literal">false</span> });
assert.deepEqual(noParsingArrays, { <span class="hljs-attr">a</span>: { <span class="hljs-string">'0'</span>: <span class="hljs-string">'b'</span> } });
</code></pre>
<p>If you mix notations, <strong>qs</strong> will merge the two items into an object:</p>
<pre><code class="javascript"><span class="hljs-keyword">var</span> mixedNotation = qs.parse(<span class="hljs-string">'a[0]=b&amp;a[b]=c'</span>);
assert.deepEqual(mixedNotation, { <span class="hljs-attr">a</span>: { <span class="hljs-string">'0'</span>: <span class="hljs-string">'b'</span>, <span class="hljs-attr">b</span>: <span class="hljs-string">'c'</span> } });
</code></pre>
<p>You can also create arrays of objects:</p>
<pre><code class="javascript"><span class="hljs-keyword">var</span> arraysOfObjects = qs.parse(<span class="hljs-string">'a[][b]=c'</span>);
assert.deepEqual(arraysOfObjects, { <span class="hljs-attr">a</span>: [{ <span class="hljs-attr">b</span>: <span class="hljs-string">'c'</span> }] });
</code></pre>
<div class="pilwrap" id="stringifying">
  <h3>
    <a href="#stringifying" name="stringifying" class="pilcrow"></a>
Stringifying
  </h3>
</div>
<p><a href="#preventEval.html"></a></p>
<pre><code class="javascript">qs.stringify(object, [options]);
</code></pre>
<p>When stringifying, <strong>qs</strong> by default URI encodes output. Objects are stringified as you would expect:</p>
<pre><code class="javascript">assert.equal(qs.stringify({ <span class="hljs-attr">a</span>: <span class="hljs-string">'b'</span> }), <span class="hljs-string">'a=b'</span>);
assert.equal(qs.stringify({ <span class="hljs-attr">a</span>: { <span class="hljs-attr">b</span>: <span class="hljs-string">'c'</span> } }), <span class="hljs-string">'a%5Bb%5D=c'</span>);
</code></pre>
<p>This encoding can be disabled by setting the <code>encode</code> option to <code>false</code>:</p>
<pre><code class="javascript"><span class="hljs-keyword">var</span> unencoded = qs.stringify({ <span class="hljs-attr">a</span>: { <span class="hljs-attr">b</span>: <span class="hljs-string">'c'</span> } }, { <span class="hljs-attr">encode</span>: <span class="hljs-literal">false</span> });
assert.equal(unencoded, <span class="hljs-string">'a[b]=c'</span>);
</code></pre>
<p>Encoding can be disabled for keys by setting the <code>encodeValuesOnly</code> option to <code>true</code>:</p>
<pre><code class="javascript"><span class="hljs-keyword">var</span> encodedValues = qs.stringify(
    { <span class="hljs-attr">a</span>: <span class="hljs-string">'b'</span>, <span class="hljs-attr">c</span>: [<span class="hljs-string">'d'</span>, <span class="hljs-string">'e=f'</span>], <span class="hljs-attr">f</span>: [[<span class="hljs-string">'g'</span>], [<span class="hljs-string">'h'</span>]] },
    { <span class="hljs-attr">encodeValuesOnly</span>: <span class="hljs-literal">true</span> }
);
assert.equal(encodedValues,<span class="hljs-string">'a=b&amp;c[0]=d&amp;c[1]=e%3Df&amp;f[0][0]=g&amp;f[1][0]=h'</span>);
</code></pre>
<p>This encoding can also be replaced by a custom encoding method set as <code>encoder</code> option:</p>
<pre><code class="javascript"><span class="hljs-keyword">var</span> encoded = qs.stringify({ <span class="hljs-attr">a</span>: { <span class="hljs-attr">b</span>: <span class="hljs-string">'c'</span> } }, { <span class="hljs-attr">encoder</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">str</span>) </span>{
    <span class="hljs-comment">// Passed in values `a`, `b`, `c`</span>
    <span class="hljs-keyword">return</span> <span class="hljs-comment">// Return encoded string</span>
}})
</code></pre>
<p><em>(Note: the <code>encoder</code> option does not apply if <code>encode</code> is <code>false</code>)</em></p>
<p>Analogue to the <code>encoder</code> there is a <code>decoder</code> option for <code>parse</code> to override decoding of properties and values:</p>
<pre><code class="javascript"><span class="hljs-keyword">var</span> decoded = qs.parse(<span class="hljs-string">'x=z'</span>, { <span class="hljs-attr">decoder</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">str</span>) </span>{
    <span class="hljs-comment">// Passed in values `x`, `z`</span>
    <span class="hljs-keyword">return</span> <span class="hljs-comment">// Return decoded string</span>
}})
</code></pre>
<p>Examples beyond this point will be shown as though the output is not URI encoded for clarity. Please note that the return values in these cases <em>will</em> be URI encoded during real usage.</p>
<p>When arrays are stringified, by default they are given explicit indices:</p>
<pre><code class="javascript">qs.stringify({ <span class="hljs-attr">a</span>: [<span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>] });
<span class="hljs-comment">// 'a[0]=b&amp;a[1]=c&amp;a[2]=d'</span>
</code></pre>
<p>You may override this by setting the <code>indices</code> option to <code>false</code>:</p>
<pre><code class="javascript">qs.stringify({ <span class="hljs-attr">a</span>: [<span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>] }, { <span class="hljs-attr">indices</span>: <span class="hljs-literal">false</span> });
<span class="hljs-comment">// 'a=b&amp;a=c&amp;a=d'</span>
</code></pre>
<p>You may use the <code>arrayFormat</code> option to specify the format of the output array:</p>
<pre><code class="javascript">qs.stringify({ <span class="hljs-attr">a</span>: [<span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>] }, { <span class="hljs-attr">arrayFormat</span>: <span class="hljs-string">'indices'</span> })
<span class="hljs-comment">// 'a[0]=b&amp;a[1]=c'</span>
qs.stringify({ <span class="hljs-attr">a</span>: [<span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>] }, { <span class="hljs-attr">arrayFormat</span>: <span class="hljs-string">'brackets'</span> })
<span class="hljs-comment">// 'a[]=b&amp;a[]=c'</span>
qs.stringify({ <span class="hljs-attr">a</span>: [<span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>] }, { <span class="hljs-attr">arrayFormat</span>: <span class="hljs-string">'repeat'</span> })
<span class="hljs-comment">// 'a=b&amp;a=c'</span>
</code></pre>
<p>When objects are stringified, by default they use bracket notation:</p>
<pre><code class="javascript">qs.stringify({ <span class="hljs-attr">a</span>: { <span class="hljs-attr">b</span>: { <span class="hljs-attr">c</span>: <span class="hljs-string">'d'</span>, <span class="hljs-attr">e</span>: <span class="hljs-string">'f'</span> } } });
<span class="hljs-comment">// 'a[b][c]=d&amp;a[b][e]=f'</span>
</code></pre>
<p>You may override this to use dot notation by setting the <code>allowDots</code> option to <code>true</code>:</p>
<pre><code class="javascript">qs.stringify({ <span class="hljs-attr">a</span>: { <span class="hljs-attr">b</span>: { <span class="hljs-attr">c</span>: <span class="hljs-string">'d'</span>, <span class="hljs-attr">e</span>: <span class="hljs-string">'f'</span> } } }, { <span class="hljs-attr">allowDots</span>: <span class="hljs-literal">true</span> });
<span class="hljs-comment">// 'a.b.c=d&amp;a.b.e=f'</span>
</code></pre>
<p>Empty strings and null values will omit the value, but the equals sign (=) remains in place:</p>
<pre><code class="javascript">assert.equal(qs.stringify({ <span class="hljs-attr">a</span>: <span class="hljs-string">''</span> }), <span class="hljs-string">'a='</span>);
</code></pre>
<p>Key with no values (such as an empty object or array) will return nothing:</p>
<pre><code class="javascript">assert.equal(qs.stringify({ <span class="hljs-attr">a</span>: [] }), <span class="hljs-string">''</span>);
assert.equal(qs.stringify({ <span class="hljs-attr">a</span>: {} }), <span class="hljs-string">''</span>);
assert.equal(qs.stringify({ <span class="hljs-attr">a</span>: [{}] }), <span class="hljs-string">''</span>);
assert.equal(qs.stringify({ <span class="hljs-attr">a</span>: { <span class="hljs-attr">b</span>: []} }), <span class="hljs-string">''</span>);
assert.equal(qs.stringify({ <span class="hljs-attr">a</span>: { <span class="hljs-attr">b</span>: {}} }), <span class="hljs-string">''</span>);
</code></pre>
<p>Properties that are set to <code>undefined</code> will be omitted entirely:</p>
<pre><code class="javascript">assert.equal(qs.stringify({ <span class="hljs-attr">a</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">b</span>: <span class="hljs-literal">undefined</span> }), <span class="hljs-string">'a='</span>);
</code></pre>
<p>The query string may optionally be prepended with a question mark:</p>
<pre><code class="javascript">assert.equal(qs.stringify({ <span class="hljs-attr">a</span>: <span class="hljs-string">'b'</span>, <span class="hljs-attr">c</span>: <span class="hljs-string">'d'</span> }, { <span class="hljs-attr">addQueryPrefix</span>: <span class="hljs-literal">true</span> }), <span class="hljs-string">'?a=b&amp;c=d'</span>);
</code></pre>
<p>The delimiter may be overridden with stringify as well:</p>
<pre><code class="javascript">assert.equal(qs.stringify({ <span class="hljs-attr">a</span>: <span class="hljs-string">'b'</span>, <span class="hljs-attr">c</span>: <span class="hljs-string">'d'</span> }, { <span class="hljs-attr">delimiter</span>: <span class="hljs-string">';'</span> }), <span class="hljs-string">'a=b;c=d'</span>);
</code></pre>
<p>If you only want to override the serialization of <code>Date</code> objects, you can provide a <code>serializeDate</code> option:</p>
<pre><code class="javascript"><span class="hljs-keyword">var</span> date = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">7</span>);
assert.equal(qs.stringify({ <span class="hljs-attr">a</span>: date }), <span class="hljs-string">'a=1970-01-01T00:00:00.007Z'</span>.replace(<span class="hljs-regexp">/:/g</span>, <span class="hljs-string">'%3A'</span>));
assert.equal(
    qs.stringify({ <span class="hljs-attr">a</span>: date }, { <span class="hljs-attr">serializeDate</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">d</span>) </span>{ <span class="hljs-keyword">return</span> d.getTime(); } }),
    <span class="hljs-string">'a=7'</span>
);
</code></pre>
<p>You may use the <code>sort</code> option to affect the order of parameter keys:</p>
<pre><code class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">alphabeticalSort</span>(<span class="hljs-params">a, b</span>) </span>{
    <span class="hljs-keyword">return</span> a.localeCompare(b);
}
assert.equal(qs.stringify({ <span class="hljs-attr">a</span>: <span class="hljs-string">'c'</span>, <span class="hljs-attr">z</span>: <span class="hljs-string">'y'</span>, <span class="hljs-attr">b</span> : <span class="hljs-string">'f'</span> }, { <span class="hljs-attr">sort</span>: alphabeticalSort }), <span class="hljs-string">'a=c&amp;b=f&amp;z=y'</span>);
</code></pre>
<p>Finally, you can use the <code>filter</code> option to restrict which keys will be included in the stringified output.
If you pass a function, it will be called for each key to obtain the replacement value. Otherwise, if you
pass an array, it will be used to select properties and array indices for stringification:</p>
<pre><code class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">filterFunc</span>(<span class="hljs-params">prefix, value</span>) </span>{
    <span class="hljs-keyword">if</span> (prefix == <span class="hljs-string">'b'</span>) {
        <span class="hljs-comment">// Return an `undefined` value to omit a property.</span>
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-keyword">if</span> (prefix == <span class="hljs-string">'e[f]'</span>) {
        <span class="hljs-keyword">return</span> value.getTime();
    }
    <span class="hljs-keyword">if</span> (prefix == <span class="hljs-string">'e[g][0]'</span>) {
        <span class="hljs-keyword">return</span> value * <span class="hljs-number">2</span>;
    }
    <span class="hljs-keyword">return</span> value;
}
qs.stringify({ <span class="hljs-attr">a</span>: <span class="hljs-string">'b'</span>, <span class="hljs-attr">c</span>: <span class="hljs-string">'d'</span>, <span class="hljs-attr">e</span>: { <span class="hljs-attr">f</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">123</span>), <span class="hljs-attr">g</span>: [<span class="hljs-number">2</span>] } }, { <span class="hljs-attr">filter</span>: filterFunc });
<span class="hljs-comment">// 'a=b&amp;c=d&amp;e[f]=123&amp;e[g][0]=4'</span>
qs.stringify({ <span class="hljs-attr">a</span>: <span class="hljs-string">'b'</span>, <span class="hljs-attr">c</span>: <span class="hljs-string">'d'</span>, <span class="hljs-attr">e</span>: <span class="hljs-string">'f'</span> }, { <span class="hljs-attr">filter</span>: [<span class="hljs-string">'a'</span>, <span class="hljs-string">'e'</span>] });
<span class="hljs-comment">// 'a=b&amp;e=f'</span>
qs.stringify({ <span class="hljs-attr">a</span>: [<span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>], <span class="hljs-attr">e</span>: <span class="hljs-string">'f'</span> }, { <span class="hljs-attr">filter</span>: [<span class="hljs-string">'a'</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>] });
<span class="hljs-comment">// 'a[0]=b&amp;a[2]=d'</span>
</code></pre>
<div class="pilwrap" id="handling-of-null-values">
  <h3>
    <a href="#handling-of-null-values" name="handling-of-null-values" class="pilcrow"></a>
Handling of <code>null</code> values
  </h3>
</div>
<p>By default, <code>null</code> values are treated like empty strings:</p>
<pre><code class="javascript"><span class="hljs-keyword">var</span> withNull = qs.stringify({ <span class="hljs-attr">a</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">b</span>: <span class="hljs-string">''</span> });
assert.equal(withNull, <span class="hljs-string">'a=&amp;b='</span>);
</code></pre>
<p>Parsing does not distinguish between parameters with and without equal signs. Both are converted to empty strings.</p>
<pre><code class="javascript"><span class="hljs-keyword">var</span> equalsInsensitive = qs.parse(<span class="hljs-string">'a&amp;b='</span>);
assert.deepEqual(equalsInsensitive, { <span class="hljs-attr">a</span>: <span class="hljs-string">''</span>, <span class="hljs-attr">b</span>: <span class="hljs-string">''</span> });
</code></pre>
<p>To distinguish between <code>null</code> values and empty strings use the <code>strictNullHandling</code> flag. In the result string the <code>null</code>
values have no <code>=</code> sign:</p>
<pre><code class="javascript"><span class="hljs-keyword">var</span> strictNull = qs.stringify({ <span class="hljs-attr">a</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">b</span>: <span class="hljs-string">''</span> }, { <span class="hljs-attr">strictNullHandling</span>: <span class="hljs-literal">true</span> });
assert.equal(strictNull, <span class="hljs-string">'a&amp;b='</span>);
</code></pre>
<p>To parse values without <code>=</code> back to <code>null</code> use the <code>strictNullHandling</code> flag:</p>
<pre><code class="javascript"><span class="hljs-keyword">var</span> parsedStrictNull = qs.parse(<span class="hljs-string">'a&amp;b='</span>, { <span class="hljs-attr">strictNullHandling</span>: <span class="hljs-literal">true</span> });
assert.deepEqual(parsedStrictNull, { <span class="hljs-attr">a</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">b</span>: <span class="hljs-string">''</span> });
</code></pre>
<p>To completely skip rendering keys with <code>null</code> values, use the <code>skipNulls</code> flag:</p>
<pre><code class="javascript"><span class="hljs-keyword">var</span> nullsSkipped = qs.stringify({ <span class="hljs-attr">a</span>: <span class="hljs-string">'b'</span>, <span class="hljs-attr">c</span>: <span class="hljs-literal">null</span>}, { <span class="hljs-attr">skipNulls</span>: <span class="hljs-literal">true</span> });
assert.equal(nullsSkipped, <span class="hljs-string">'a=b'</span>);
</code></pre>
<div class="pilwrap" id="dealing-with-special-character-sets">
  <h3>
    <a href="#dealing-with-special-character-sets" name="dealing-with-special-character-sets" class="pilcrow"></a>
Dealing with special character sets
  </h3>
</div>
<p>By default the encoding and decoding of characters is done in <code>utf-8</code>. If you
wish to encode querystrings to a different character set (i.e.
<a href="https://en.wikipedia.org/wiki/Shift_JIS">Shift JIS</a>) you can use the
<a href="https://github.com/martinheidegger/qs-iconv"><code>qs-iconv</code></a> library:</p>
<pre><code class="javascript"><span class="hljs-keyword">var</span> encoder = <span class="hljs-built_in">require</span>(<span class="hljs-string">'qs-iconv/encoder'</span>)(<span class="hljs-string">'shift_jis'</span>);
<span class="hljs-keyword">var</span> shiftJISEncoded = qs.stringify({ <span class="hljs-attr">a</span>: <span class="hljs-string">'こんにちは！'</span> }, { <span class="hljs-attr">encoder</span>: encoder });
assert.equal(shiftJISEncoded, <span class="hljs-string">'a=%82%B1%82%F1%82%C9%82%BF%82%CD%81I'</span>);
</code></pre>
<p>This also works for decoding of query strings:</p>
<pre><code class="javascript"><span class="hljs-keyword">var</span> decoder = <span class="hljs-built_in">require</span>(<span class="hljs-string">'qs-iconv/decoder'</span>)(<span class="hljs-string">'shift_jis'</span>);
<span class="hljs-keyword">var</span> obj = qs.parse(<span class="hljs-string">'a=%82%B1%82%F1%82%C9%82%BF%82%CD%81I'</span>, { <span class="hljs-attr">decoder</span>: decoder });
assert.deepEqual(obj, { <span class="hljs-attr">a</span>: <span class="hljs-string">'こんにちは！'</span> });
</code></pre>
<div class="pilwrap" id="rfc-3986-and-rfc-1738-space-encoding">
  <h3>
    <a href="#rfc-3986-and-rfc-1738-space-encoding" name="rfc-3986-and-rfc-1738-space-encoding" class="pilcrow"></a>
RFC 3986 and RFC 1738 space encoding
  </h3>
</div>
<p>RFC3986 used as default option and encodes ' ' to <em>%20</em> which is backward compatible.
In the same time, output can be stringified as per RFC1738 with ' ' equal to '+'.</p>
<pre><code>assert.equal(qs.stringify({ a: 'b c' }), 'a=b%20c');
assert.equal(qs.stringify({ a: 'b c' }, { format : 'RFC3986' }), 'a=b%20c');
assert.equal(qs.stringify({ a: 'b c' }, { format : 'RFC1738' }), 'a=b+c');
</code></pre>
</div>
  </div>
</body>
</html>
