<!DOCTYPE html>
<html>
<head>
  <title>README.md</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="../../doc-style.css" />
  <script src="../../doc-filelist.js"></script>
  <script>
    var relativeDir = "../../";
    var thisFile = "node_modules\\prisma-binding\\README.md";
    var defaultSidebar = true;
  </script>
  <script src="../../doc-script.js"></script>

</head>
<body>
  <div id="sidebar_wrapper">
    <div id="sidebar_switch">
      <span class="tree">Files</span>
      <span class="headings">Headings</span>
    </div>
    <div id="tree"></div>
    <div id="headings">

      <div class="heading h1">
        <a href="#prisma-binding">prisma-binding</a>
      </div>

      <div class="heading h2">
        <a href="#example">Example</a>
      </div>

      <div class="heading h2">
        <a href="#overview">Overview</a>
      </div>

      <div class="heading h2">
        <a href="#install">Install</a>
      </div>

      <div class="heading h2">
        <a href="#example-1">Example</a>
      </div>

      <div class="heading h2">
        <a href="#api">API</a>
      </div>

      <div class="heading h3">
        <a href="#constructor-options-prismaoptions-prisma">constructor(options: PrismaOptions): Prisma</a>
      </div>

      <div class="heading h3">
        <a href="#query-and-mutation">query and mutation</a>
      </div>

      <div class="heading h3">
        <a href="#exists">exists</a>
      </div>

      <div class="heading h3">
        <a href="#request">request</a>
      </div>

      <div class="heading h3">
        <a href="#forwardto">forwardTo</a>
      </div>

      <div class="heading h2">
        <a href="#usage">Usage</a>
      </div>

      <div class="heading h2">
        <a href="#next-steps">Next steps</a>
      </div>

    </div>
  </div>
  <div id="sidebar-toggle"></div>
  <div id="container">
    <div class="docs markdown"><div class="pilwrap" id="prisma-binding">
  <h1>
    <a href="#prisma-binding" name="prisma-binding" class="pilcrow"></a>
prisma-binding
  </h1>
</div>
<p><a href="https://circleci.com/gh/prismagraphql/prisma-binding"><img src="https://circleci.com/gh/prismagraphql/prisma-binding.svg?style=shield" alt="CircleCI"></a> <a href="https://badge.fury.io/js/prisma-binding"><img src="https://badge.fury.io/js/prisma-binding.svg" alt="npm version"></a></p>
<p>GraphQL Binding for Prisma services (GraphQL Database)</p>
<div class="pilwrap" id="example">
  <h2>
    <a href="#example" name="example" class="pilcrow"></a>
Example
  </h2>
</div>
<p>You can check out an example of how to use <code>prisma-binding</code> together with codegen <a href="https://github.com/graphql-binding/graphql-binding/tree/master/examples/full-example">here</a> and <a href="https://github.com/prismagraphql/graphql-server-example">here</a></p>
<div class="pilwrap" id="overview">
  <h2>
    <a href="#overview" name="overview" class="pilcrow"></a>
Overview
  </h2>
</div>
<p><code>prisma-binding</code> provides a convenience layer for building GraphQL servers on top of Prisma services. In short, it simplifies implementing your GraphQL resolvers by <em>delegating</em> execution of queries (or mutations) to the API of the underlying Prisma database service.</p>
<p>Here is how it works:</p>
<ol>
<li>Create your Prisma service by defining data model</li>
<li>Download generated database schema definition <code>prisma.graphql</code> (contains the full CRUD API)</li>
<li>Define your application schema, typically called <code>app.graphql</code></li>
<li>Instantiate <code>Prisma</code> with information about your Prisma service (such as its endpoint and the path to the database schema definition)</li>
<li>Implement the resolvers for your application schema by delegating to the underlying Prisma service using the generated delegate resolver functions</li>
</ol>
<blockquote>
<p><strong>Note</strong>: If you're using a <a href="https://github.com/graphql-boilerplates/">GraphQL boilerplate</a> project (e.g. with <code>graphql create</code>), the Prisma binding will already be configured and a few example resolvers implemented for you. You can either try the <em>dynamic binding</em> (e.g. in the <a href="https://github.com/graphql-boilerplates/node-graphql-server/tree/master/basic"><code>node-basic</code></a> boilerplate) or a <em>static binding</em> (e.g in the <a href="https://github.com/graphql-boilerplates/typescript-graphql-server/tree/master/basic"><code>typescript-basic</code></a> boilerplate).</p>
</blockquote>
<div class="pilwrap" id="install">
  <h2>
    <a href="#install" name="install" class="pilcrow"></a>
Install
  </h2>
</div>
<pre><code class="sh">yarn add prisma-binding
<span class="hljs-comment"># or</span>
npm install --save prisma-binding
</code></pre>
<div class="pilwrap" id="example-1">
  <h2>
    <a href="#example-1" name="example-1" class="pilcrow"></a>
Example
  </h2>
</div>
<p>Consider the following data model for your Prisma service:</p>
<pre><code class="graphql">type User {
  id: ID! @unique
  name: String
}
</code></pre>
<p>If you instantiate <code>Prisma</code> based on this service, you'll be able to send the following queries/mutations:</p>
<pre><code class="js"><span class="hljs-comment">// Instantiate `Prisma` based on concrete service</span>
<span class="hljs-keyword">const</span> prisma = <span class="hljs-keyword">new</span> Prisma({
  <span class="hljs-attr">typeDefs</span>: <span class="hljs-string">'schemas/database.graphql'</span>,
  <span class="hljs-attr">endpoint</span>: <span class="hljs-string">'https://us1.prisma.sh/demo/my-service/dev'</span>,
  <span class="hljs-attr">secret</span>: <span class="hljs-string">'my-super-secret-secret'</span>
})

<span class="hljs-comment">// Retrieve `name` of a specific user</span>
prisma.query.user({ <span class="hljs-attr">where</span>: { <span class="hljs-attr">id</span>: <span class="hljs-string">'abc'</span> } }, <span class="hljs-string">'{ name }'</span>)

<span class="hljs-comment">// Retrieve `id` and `name` of all users</span>
prisma.query.users(<span class="hljs-literal">null</span>, <span class="hljs-string">'{ id name }'</span>)

<span class="hljs-comment">// Create new user called `Sarah` and retrieve the `id`</span>
prisma.mutation.createUser({ <span class="hljs-attr">data</span>: { <span class="hljs-attr">name</span>: <span class="hljs-string">'Sarah'</span> } }, <span class="hljs-string">'{ id }'</span>)

<span class="hljs-comment">// Update name of a specific user and retrieve the `id`</span>
prisma.mutation.updateUser({ <span class="hljs-attr">where</span>: { <span class="hljs-attr">id</span>: <span class="hljs-string">'abc'</span> }, <span class="hljs-attr">data</span>: { <span class="hljs-attr">name</span>: <span class="hljs-string">'Sarah'</span> } }, <span class="hljs-string">'{ id }'</span>)

<span class="hljs-comment">// Delete a specific user and retrieve the `id`</span>
prisma.mutation.deleteUser({ <span class="hljs-attr">where</span>: { <span class="hljs-attr">id</span>: <span class="hljs-string">'abc'</span> } }, <span class="hljs-string">'{ id }'</span>)
</code></pre>
<p>Under the hood, each of these function calls is simply translated into an actual HTTP request against your Prisma service (using <a href="https://github.com/graphcool/graphql-request"><code>graphql-request</code></a>).</p>
<p>The API also allows to ask whether a specific node exists in your Prisma database:</p>
<pre><code class="js"><span class="hljs-comment">// Ask whether a post exists with `id` equal to `abc` and whose</span>
<span class="hljs-comment">// `author` is called `Sarah` (return boolean value)</span>
prisma.exists.Post({
  <span class="hljs-attr">id</span>: <span class="hljs-string">'abc'</span>,
  <span class="hljs-attr">author</span>: {
    <span class="hljs-attr">name</span>: <span class="hljs-string">'Sarah'</span>
  }
})
</code></pre>
<div class="pilwrap" id="api">
  <h2>
    <a href="#api" name="api" class="pilcrow"></a>
API
  </h2>
</div>
<div class="pilwrap" id="constructor-options-prismaoptions-prisma">
  <h3>
    <a href="#constructor-options-prismaoptions-prisma" name="constructor-options-prismaoptions-prisma" class="pilcrow"></a>
<code>constructor(options: PrismaOptions): Prisma</code>
  </h3>
</div>
<p>The <code>PrismaOptions</code> type has the following fields:</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Required</th>
<th>Type</th>
<th>Default</th>
<th>Note</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>typeDefs</code></td>
<td>Yes</td>
<td><code>string</code></td>
<td>-</td>
<td>Type definition string or file path to the schema definition of your Prisma service (typically a file called <code>database.graphql</code> or <code>prisma.graphql</code>)</td>
</tr>
<tr>
<td><code>endpoint</code></td>
<td>Yes</td>
<td><code>string</code></td>
<td>-</td>
<td>The endpoint of your Prisma service</td>
</tr>
<tr>
<td><code>secret</code></td>
<td>Yes</td>
<td><code>string</code></td>
<td>-</td>
<td>The secret of your Prisma service</td>
</tr>
<tr>
<td><code>fragmentReplacements</code></td>
<td>No</td>
<td><code>FragmentReplacements</code></td>
<td><code>null</code></td>
<td>A list of GraphQL fragment definitions, specifying fields that are required for the resolver to function correctly</td>
</tr>
<tr>
<td><code>debug</code></td>
<td>No</td>
<td><code>boolean</code></td>
<td><code>false</code></td>
<td>Log all queries/mutations to the console</td>
</tr>
</tbody>
</table>
<div class="pilwrap" id="query-and-mutation">
  <h3>
    <a href="#query-and-mutation" name="query-and-mutation" class="pilcrow"></a>
<code>query</code> and <code>mutation</code>
  </h3>
</div>
<p><code>query</code> and <code>mutation</code> are public properties on your <code>Prisma</code> instance. They both are of type <code>Query</code> and expose a number of auto-generated delegate resolver functions that are named after the fields on the <code>Query</code> and <code>Mutation</code> types in your Prisma database schema.</p>
<p>Each of these delegate resolvers in essence provides a convenience API for sending queries/mutations to your Prisma service, so you don't have to spell out the full query/mutation from scratch and worry about sending it over HTTP. This is all handled by the delegate resolver function under the hood.</p>
<p>Delegate resolver have the following interface:</p>
<pre><code class="js">(args: any, <span class="hljs-attr">info</span>: GraphQLResolveInfo | string): <span class="hljs-built_in">Promise</span>&lt;T&gt;
</code></pre>
<p>The input arguments are used as follows:</p>
<ul>
<li><code>args</code>: An object carrying potential arguments for the query/mutation</li>
<li><code>info</code>: An object representing the selection set of the query/mutation, either expressed directly as a string or in the form of <code>GraphQLResolveInfo</code> (you can find more info about the <code>GraphQLResolveInfo</code> type <a href="http://graphql.org/graphql-js/type/#graphqlobjecttype">here</a>)</li>
</ul>
<p>The generic type <code>T</code> corresponds to the type of the respective field.</p>
<div class="pilwrap" id="exists">
  <h3>
    <a href="#exists" name="exists" class="pilcrow"></a>
<code>exists</code>
  </h3>
</div>
<p><code>exists</code> also is a public property on your <code>Prisma</code> instance. Similar to <code>query</code> and <code>mutation</code>, it also exposes a number of auto-generated functions. However, it exposes only a single function per type. This function is named according to the root field that allows the retrieval of a single node of that type (e.g. <code>User</code> for a type called <code>User</code>). It takes a <code>where</code> object as an input argument and returns a <code>boolean</code> value indicating whether the condition expressed with <code>where</code> is met.</p>
<p>This function enables you to easily check whether a node of a specific type exists in your Prisma database.</p>
<div class="pilwrap" id="request">
  <h3>
    <a href="#request" name="request" class="pilcrow"></a>
<code>request</code>
  </h3>
</div>
<p>The <code>request</code> method lets you send GraphQL queries/mutations to your Prisma service. The functionality is identical to the auto-generated delegate resolves, but the API is more verbose as you need to spell out the full query/mutation. <code>request</code> uses <a href="https://github.com/graphcool/graphql-request"><code>graphql-request</code></a> under the hood.</p>
<p>Here is an example of how it can be used:</p>
<pre><code class="js"><span class="hljs-keyword">const</span> query = <span class="hljs-string">`
  query ($userId: ID!){
    user(id: $userId) {
      id
      name
    }
  }
`</span>

<span class="hljs-keyword">const</span> variables = { <span class="hljs-attr">userId</span>: <span class="hljs-string">'abc'</span> }

prisma.request(query, variables)
  .then(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(result))
<span class="hljs-comment">// sample result:</span>
<span class="hljs-comment">// {"data": { "user": { "id": "abc", "name": "Sarah" } } }</span>
</code></pre>
<div class="pilwrap" id="forwardto">
  <h3>
    <a href="#forwardto" name="forwardto" class="pilcrow"></a>
<code>forwardTo</code>
  </h3>
</div>
<p>If you just want to forward a query to the exact same underlying prisma query, you can use <code>forwardTo</code>:</p>
<pre><code class="js"><span class="hljs-keyword">const</span> {forwardTo} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'prisma-binding'</span>)

<span class="hljs-keyword">const</span> resolvers = {
  <span class="hljs-attr">Query</span>: {
    <span class="hljs-attr">posts</span>: forwardTo(<span class="hljs-string">'db'</span>)
  }
}

<span class="hljs-keyword">const</span> server = <span class="hljs-keyword">new</span> GraphQLServer({
  <span class="hljs-attr">typeDefs</span>: <span class="hljs-string">'./src/schema.graphql'</span>,
  resolvers,
  <span class="hljs-attr">context</span>: <span class="hljs-function"><span class="hljs-params">req</span> =&gt;</span> ({
    ...req,
    <span class="hljs-attr">db</span>: <span class="hljs-keyword">new</span> Prisma({
      <span class="hljs-attr">typeDefs</span>: <span class="hljs-string">'src/generated/prisma.graphql'</span>,
      <span class="hljs-attr">endpoint</span>: <span class="hljs-string">'...'</span>,
      <span class="hljs-attr">secret</span>: <span class="hljs-string">'mysecret123'</span>,
    }),
    <span class="hljs-attr">debug</span>: <span class="hljs-literal">true</span>,
  }),
})

server.start(
  <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Server is running on http://localhost:4000`</span>),
)
</code></pre>
<div class="pilwrap" id="usage">
  <h2>
    <a href="#usage" name="usage" class="pilcrow"></a>
Usage
  </h2>
</div>
<ul>
<li><a href="https://github.com/graphql-boilerplates">graphql-boilerplates</a>.</li>
<li><a href="https://github.com/graphcool/graphql-server-example">graphql-server-example</a>.</li>
</ul>
<div class="pilwrap" id="next-steps">
  <h2>
    <a href="#next-steps" name="next-steps" class="pilcrow"></a>
Next steps
  </h2>
</div>
<ul>
<li>Code generation at build-time for the auto-generated delegate resolvers</li>
</ul>
<p align="center"><a href="https://oss.prisma.io"><img src="https://imgur.com/IMU2ERq.png" alt="Prisma" height="170px"></a></p>
</div>
  </div>
</body>
</html>
