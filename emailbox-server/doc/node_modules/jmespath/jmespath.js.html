<!DOCTYPE html>
<html>
<head>
  <title>jmespath.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="../../doc-style.css" />
  <script src="../../doc-filelist.js"></script>
  <script>
    var relativeDir = "../../";
    var thisFile = "node_modules\\jmespath\\jmespath.js";
    var defaultSidebar = true;
  </script>
  <script src="../../doc-script.js"></script>

</head>
<body>
  <div id="sidebar_wrapper">
    <div id="sidebar_switch">
      <span class="tree">Files</span>
      <span class="headings">Headings</span>
    </div>
    <div id="tree"></div>
    <div id="headings">

    </div>
  </div>
  <div id="sidebar-toggle"></div>
  <div id="container">
    <div class="background highlight"></div>
<table cellpadding="0" cellspacing="0">
  <tbody>
    
      <tr>
        <td class="docs">
          <h1>jmespath.js</h1>
        </td>
        <td class="code highlight"></td>
      </tr>
    
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1" id="section-1"></a>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">exports</span>) </span>{
<span class="hljs-meta">  "use strict"</span>;

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isArray</span>(<span class="hljs-params">obj</span>) </span>{
    <span class="hljs-keyword">if</span> (obj !== <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.prototype.toString.call(obj) === <span class="hljs-string">"[object Array]"</span>;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isObject</span>(<span class="hljs-params">obj</span>) </span>{
    <span class="hljs-keyword">if</span> (obj !== <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.prototype.toString.call(obj) === <span class="hljs-string">"[object Object]"</span>;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">strictDeepEqual</span>(<span class="hljs-params">first, second</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-2" id="section-2"></a>
</div>
<p>Check the scalar case first.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">if</span> (first === second) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-3" id="section-3"></a>
</div>
<p>Check if they are the same type.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">var</span> firstType = <span class="hljs-built_in">Object</span>.prototype.toString.call(first);
    <span class="hljs-keyword">if</span> (firstType !== <span class="hljs-built_in">Object</span>.prototype.toString.call(second)) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-4" id="section-4"></a>
</div>
<p>We know that first and second have the same type so we can just check the
first type from now on.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">if</span> (isArray(first) === <span class="hljs-literal">true</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-5" id="section-5"></a>
</div>
<p>Short circuit if they're not the same length;</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">if</span> (first.length !== second.length) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; first.length; i++) {
        <span class="hljs-keyword">if</span> (strictDeepEqual(first[i], second[i]) === <span class="hljs-literal">false</span>) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
      }
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
    <span class="hljs-keyword">if</span> (isObject(first) === <span class="hljs-literal">true</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-6" id="section-6"></a>
</div>
<p>An object is equal if it has the same key/value pairs.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">var</span> keysSeen = {};
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> first) {
        <span class="hljs-keyword">if</span> (hasOwnProperty.call(first, key)) {
          <span class="hljs-keyword">if</span> (strictDeepEqual(first[key], second[key]) === <span class="hljs-literal">false</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
          }
          keysSeen[key] = <span class="hljs-literal">true</span>;
        }
      }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-7" id="section-7"></a>
</div>
<p>Now check that there aren't any keys in second that weren't
in first.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key2 <span class="hljs-keyword">in</span> second) {
        <span class="hljs-keyword">if</span> (hasOwnProperty.call(second, key2)) {
          <span class="hljs-keyword">if</span> (keysSeen[key2] !== <span class="hljs-literal">true</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
          }
        }
      }
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isFalse</span>(<span class="hljs-params">obj</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-8" id="section-8"></a>
</div>
<p>From the spec:
A false value corresponds to the following values:
Empty list
Empty object
Empty string
False boolean
null value</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-9" id="section-9"></a>
</div>
<p>First check the scalar values.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">if</span> (obj === <span class="hljs-string">""</span> || obj === <span class="hljs-literal">false</span> || obj === <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isArray(obj) &amp;&amp; obj.length === <span class="hljs-number">0</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-10" id="section-10"></a>
</div>
<p>Check for an empty array.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isObject(obj)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-11" id="section-11"></a>
</div>
<p>Check for an empty object.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> obj) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-12" id="section-12"></a>
</div>
<p>If there are any keys, then
the object is not empty so the object
is not false.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">if</span> (obj.hasOwnProperty(key)) {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">objValues</span>(<span class="hljs-params">obj</span>) </span>{
    <span class="hljs-keyword">var</span> keys = <span class="hljs-built_in">Object</span>.keys(obj);
    <span class="hljs-keyword">var</span> values = [];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; keys.length; i++) {
      values.push(obj[keys[i]]);
    }
    <span class="hljs-keyword">return</span> values;
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">merge</span>(<span class="hljs-params">a, b</span>) </span>{
      <span class="hljs-keyword">var</span> merged = {};
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> a) {
          merged[key] = a[key];
      }
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key2 <span class="hljs-keyword">in</span> b) {
          merged[key2] = b[key2];
      }
      <span class="hljs-keyword">return</span> merged;
  }

  <span class="hljs-keyword">var</span> trimLeft;
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">String</span>.prototype.trimLeft === <span class="hljs-string">"function"</span>) {
    trimLeft = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">str</span>) </span>{
      <span class="hljs-keyword">return</span> str.trimLeft();
    };
  } <span class="hljs-keyword">else</span> {
    trimLeft = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">str</span>) </span>{
      <span class="hljs-keyword">return</span> str.match(<span class="hljs-regexp">/^\s*(.*)/</span>)[<span class="hljs-number">1</span>];
    };
  }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-13" id="section-13"></a>
</div>
<p>Type constants used to define functions.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-keyword">var</span> TYPE_NUMBER = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">var</span> TYPE_ANY = <span class="hljs-number">1</span>;
  <span class="hljs-keyword">var</span> TYPE_STRING = <span class="hljs-number">2</span>;
  <span class="hljs-keyword">var</span> TYPE_ARRAY = <span class="hljs-number">3</span>;
  <span class="hljs-keyword">var</span> TYPE_OBJECT = <span class="hljs-number">4</span>;
  <span class="hljs-keyword">var</span> TYPE_BOOLEAN = <span class="hljs-number">5</span>;
  <span class="hljs-keyword">var</span> TYPE_EXPREF = <span class="hljs-number">6</span>;
  <span class="hljs-keyword">var</span> TYPE_NULL = <span class="hljs-number">7</span>;
  <span class="hljs-keyword">var</span> TYPE_ARRAY_NUMBER = <span class="hljs-number">8</span>;
  <span class="hljs-keyword">var</span> TYPE_ARRAY_STRING = <span class="hljs-number">9</span>;

  <span class="hljs-keyword">var</span> TOK_EOF = <span class="hljs-string">"EOF"</span>;
  <span class="hljs-keyword">var</span> TOK_UNQUOTEDIDENTIFIER = <span class="hljs-string">"UnquotedIdentifier"</span>;
  <span class="hljs-keyword">var</span> TOK_QUOTEDIDENTIFIER = <span class="hljs-string">"QuotedIdentifier"</span>;
  <span class="hljs-keyword">var</span> TOK_RBRACKET = <span class="hljs-string">"Rbracket"</span>;
  <span class="hljs-keyword">var</span> TOK_RPAREN = <span class="hljs-string">"Rparen"</span>;
  <span class="hljs-keyword">var</span> TOK_COMMA = <span class="hljs-string">"Comma"</span>;
  <span class="hljs-keyword">var</span> TOK_COLON = <span class="hljs-string">"Colon"</span>;
  <span class="hljs-keyword">var</span> TOK_RBRACE = <span class="hljs-string">"Rbrace"</span>;
  <span class="hljs-keyword">var</span> TOK_NUMBER = <span class="hljs-string">"Number"</span>;
  <span class="hljs-keyword">var</span> TOK_CURRENT = <span class="hljs-string">"Current"</span>;
  <span class="hljs-keyword">var</span> TOK_EXPREF = <span class="hljs-string">"Expref"</span>;
  <span class="hljs-keyword">var</span> TOK_PIPE = <span class="hljs-string">"Pipe"</span>;
  <span class="hljs-keyword">var</span> TOK_OR = <span class="hljs-string">"Or"</span>;
  <span class="hljs-keyword">var</span> TOK_AND = <span class="hljs-string">"And"</span>;
  <span class="hljs-keyword">var</span> TOK_EQ = <span class="hljs-string">"EQ"</span>;
  <span class="hljs-keyword">var</span> TOK_GT = <span class="hljs-string">"GT"</span>;
  <span class="hljs-keyword">var</span> TOK_LT = <span class="hljs-string">"LT"</span>;
  <span class="hljs-keyword">var</span> TOK_GTE = <span class="hljs-string">"GTE"</span>;
  <span class="hljs-keyword">var</span> TOK_LTE = <span class="hljs-string">"LTE"</span>;
  <span class="hljs-keyword">var</span> TOK_NE = <span class="hljs-string">"NE"</span>;
  <span class="hljs-keyword">var</span> TOK_FLATTEN = <span class="hljs-string">"Flatten"</span>;
  <span class="hljs-keyword">var</span> TOK_STAR = <span class="hljs-string">"Star"</span>;
  <span class="hljs-keyword">var</span> TOK_FILTER = <span class="hljs-string">"Filter"</span>;
  <span class="hljs-keyword">var</span> TOK_DOT = <span class="hljs-string">"Dot"</span>;
  <span class="hljs-keyword">var</span> TOK_NOT = <span class="hljs-string">"Not"</span>;
  <span class="hljs-keyword">var</span> TOK_LBRACE = <span class="hljs-string">"Lbrace"</span>;
  <span class="hljs-keyword">var</span> TOK_LBRACKET = <span class="hljs-string">"Lbracket"</span>;
  <span class="hljs-keyword">var</span> TOK_LPAREN= <span class="hljs-string">"Lparen"</span>;
  <span class="hljs-keyword">var</span> TOK_LITERAL= <span class="hljs-string">"Literal"</span>;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-14" id="section-14"></a>
</div>
<p>The &quot;&amp;&quot;, &quot;[&quot;, &quot;&lt;&quot;, &quot;&gt;&quot; tokens
are not in basicToken because
there are two token variants
(&quot;&amp;&amp;&quot;, &quot;[?&quot;, &quot;&lt;=&quot;, &quot;&gt;=&quot;).  This is specially handled
below.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
  <span class="hljs-keyword">var</span> basicTokens = {
    <span class="hljs-string">"."</span>: TOK_DOT,
    <span class="hljs-string">"*"</span>: TOK_STAR,
    <span class="hljs-string">","</span>: TOK_COMMA,
    <span class="hljs-string">":"</span>: TOK_COLON,
    <span class="hljs-string">"{"</span>: TOK_LBRACE,
    <span class="hljs-string">"}"</span>: TOK_RBRACE,
    <span class="hljs-string">"]"</span>: TOK_RBRACKET,
    <span class="hljs-string">"("</span>: TOK_LPAREN,
    <span class="hljs-string">")"</span>: TOK_RPAREN,
    <span class="hljs-string">"@"</span>: TOK_CURRENT
  };

  <span class="hljs-keyword">var</span> operatorStartToken = {
      <span class="hljs-string">"&lt;"</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-string">"&gt;"</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-string">"="</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-string">"!"</span>: <span class="hljs-literal">true</span>
  };

  <span class="hljs-keyword">var</span> skipChars = {
      <span class="hljs-string">" "</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-string">"\t"</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-string">"\n"</span>: <span class="hljs-literal">true</span>
  };


  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isAlpha</span>(<span class="hljs-params">ch</span>) </span>{
      <span class="hljs-keyword">return</span> (ch &gt;= <span class="hljs-string">"a"</span> &amp;&amp; ch &lt;= <span class="hljs-string">"z"</span>) ||
             (ch &gt;= <span class="hljs-string">"A"</span> &amp;&amp; ch &lt;= <span class="hljs-string">"Z"</span>) ||
             ch === <span class="hljs-string">"_"</span>;
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isNum</span>(<span class="hljs-params">ch</span>) </span>{
      <span class="hljs-keyword">return</span> (ch &gt;= <span class="hljs-string">"0"</span> &amp;&amp; ch &lt;= <span class="hljs-string">"9"</span>) ||
             ch === <span class="hljs-string">"-"</span>;
  }
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isAlphaNum</span>(<span class="hljs-params">ch</span>) </span>{
      <span class="hljs-keyword">return</span> (ch &gt;= <span class="hljs-string">"a"</span> &amp;&amp; ch &lt;= <span class="hljs-string">"z"</span>) ||
             (ch &gt;= <span class="hljs-string">"A"</span> &amp;&amp; ch &lt;= <span class="hljs-string">"Z"</span>) ||
             (ch &gt;= <span class="hljs-string">"0"</span> &amp;&amp; ch &lt;= <span class="hljs-string">"9"</span>) ||
             ch === <span class="hljs-string">"_"</span>;
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Lexer</span>(<span class="hljs-params"></span>) </span>{
  }
  Lexer.prototype = {
      <span class="hljs-attr">tokenize</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">stream</span>) </span>{
          <span class="hljs-keyword">var</span> tokens = [];
          <span class="hljs-keyword">this</span>._current = <span class="hljs-number">0</span>;
          <span class="hljs-keyword">var</span> start;
          <span class="hljs-keyword">var</span> identifier;
          <span class="hljs-keyword">var</span> token;
          <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>._current &lt; stream.length) {
              <span class="hljs-keyword">if</span> (isAlpha(stream[<span class="hljs-keyword">this</span>._current])) {
                  start = <span class="hljs-keyword">this</span>._current;
                  identifier = <span class="hljs-keyword">this</span>._consumeUnquotedIdentifier(stream);
                  tokens.push({<span class="hljs-attr">type</span>: TOK_UNQUOTEDIDENTIFIER,
                               <span class="hljs-attr">value</span>: identifier,
                               <span class="hljs-attr">start</span>: start});
              } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (basicTokens[stream[<span class="hljs-keyword">this</span>._current]] !== <span class="hljs-literal">undefined</span>) {
                  tokens.push({<span class="hljs-attr">type</span>: basicTokens[stream[<span class="hljs-keyword">this</span>._current]],
                              <span class="hljs-attr">value</span>: stream[<span class="hljs-keyword">this</span>._current],
                              <span class="hljs-attr">start</span>: <span class="hljs-keyword">this</span>._current});
                  <span class="hljs-keyword">this</span>._current++;
              } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isNum(stream[<span class="hljs-keyword">this</span>._current])) {
                  token = <span class="hljs-keyword">this</span>._consumeNumber(stream);
                  tokens.push(token);
              } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (stream[<span class="hljs-keyword">this</span>._current] === <span class="hljs-string">"["</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-15" id="section-15"></a>
</div>
<p>No need to increment this._current.  This happens
in _consumeLBracket</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                  token = <span class="hljs-keyword">this</span>._consumeLBracket(stream);
                  tokens.push(token);
              } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (stream[<span class="hljs-keyword">this</span>._current] === <span class="hljs-string">"\""</span>) {
                  start = <span class="hljs-keyword">this</span>._current;
                  identifier = <span class="hljs-keyword">this</span>._consumeQuotedIdentifier(stream);
                  tokens.push({<span class="hljs-attr">type</span>: TOK_QUOTEDIDENTIFIER,
                               <span class="hljs-attr">value</span>: identifier,
                               <span class="hljs-attr">start</span>: start});
              } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (stream[<span class="hljs-keyword">this</span>._current] === <span class="hljs-string">"'"</span>) {
                  start = <span class="hljs-keyword">this</span>._current;
                  identifier = <span class="hljs-keyword">this</span>._consumeRawStringLiteral(stream);
                  tokens.push({<span class="hljs-attr">type</span>: TOK_LITERAL,
                               <span class="hljs-attr">value</span>: identifier,
                               <span class="hljs-attr">start</span>: start});
              } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (stream[<span class="hljs-keyword">this</span>._current] === <span class="hljs-string">"`"</span>) {
                  start = <span class="hljs-keyword">this</span>._current;
                  <span class="hljs-keyword">var</span> literal = <span class="hljs-keyword">this</span>._consumeLiteral(stream);
                  tokens.push({<span class="hljs-attr">type</span>: TOK_LITERAL,
                               <span class="hljs-attr">value</span>: literal,
                               <span class="hljs-attr">start</span>: start});
              } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (operatorStartToken[stream[<span class="hljs-keyword">this</span>._current]] !== <span class="hljs-literal">undefined</span>) {
                  tokens.push(<span class="hljs-keyword">this</span>._consumeOperator(stream));
              } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (skipChars[stream[<span class="hljs-keyword">this</span>._current]] !== <span class="hljs-literal">undefined</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-16" id="section-16"></a>
</div>
<p>Ignore whitespace.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                  <span class="hljs-keyword">this</span>._current++;
              } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (stream[<span class="hljs-keyword">this</span>._current] === <span class="hljs-string">"&amp;"</span>) {
                  start = <span class="hljs-keyword">this</span>._current;
                  <span class="hljs-keyword">this</span>._current++;
                  <span class="hljs-keyword">if</span> (stream[<span class="hljs-keyword">this</span>._current] === <span class="hljs-string">"&amp;"</span>) {
                      <span class="hljs-keyword">this</span>._current++;
                      tokens.push({<span class="hljs-attr">type</span>: TOK_AND, <span class="hljs-attr">value</span>: <span class="hljs-string">"&amp;&amp;"</span>, <span class="hljs-attr">start</span>: start});
                  } <span class="hljs-keyword">else</span> {
                      tokens.push({<span class="hljs-attr">type</span>: TOK_EXPREF, <span class="hljs-attr">value</span>: <span class="hljs-string">"&amp;"</span>, <span class="hljs-attr">start</span>: start});
                  }
              } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (stream[<span class="hljs-keyword">this</span>._current] === <span class="hljs-string">"|"</span>) {
                  start = <span class="hljs-keyword">this</span>._current;
                  <span class="hljs-keyword">this</span>._current++;
                  <span class="hljs-keyword">if</span> (stream[<span class="hljs-keyword">this</span>._current] === <span class="hljs-string">"|"</span>) {
                      <span class="hljs-keyword">this</span>._current++;
                      tokens.push({<span class="hljs-attr">type</span>: TOK_OR, <span class="hljs-attr">value</span>: <span class="hljs-string">"||"</span>, <span class="hljs-attr">start</span>: start});
                  } <span class="hljs-keyword">else</span> {
                      tokens.push({<span class="hljs-attr">type</span>: TOK_PIPE, <span class="hljs-attr">value</span>: <span class="hljs-string">"|"</span>, <span class="hljs-attr">start</span>: start});
                  }
              } <span class="hljs-keyword">else</span> {
                  <span class="hljs-keyword">var</span> error = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Unknown character:"</span> + stream[<span class="hljs-keyword">this</span>._current]);
                  error.name = <span class="hljs-string">"LexerError"</span>;
                  <span class="hljs-keyword">throw</span> error;
              }
          }
          <span class="hljs-keyword">return</span> tokens;
      },

      <span class="hljs-attr">_consumeUnquotedIdentifier</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">stream</span>) </span>{
          <span class="hljs-keyword">var</span> start = <span class="hljs-keyword">this</span>._current;
          <span class="hljs-keyword">this</span>._current++;
          <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>._current &lt; stream.length &amp;&amp; isAlphaNum(stream[<span class="hljs-keyword">this</span>._current])) {
              <span class="hljs-keyword">this</span>._current++;
          }
          <span class="hljs-keyword">return</span> stream.slice(start, <span class="hljs-keyword">this</span>._current);
      },

      <span class="hljs-attr">_consumeQuotedIdentifier</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">stream</span>) </span>{
          <span class="hljs-keyword">var</span> start = <span class="hljs-keyword">this</span>._current;
          <span class="hljs-keyword">this</span>._current++;
          <span class="hljs-keyword">var</span> maxLength = stream.length;
          <span class="hljs-keyword">while</span> (stream[<span class="hljs-keyword">this</span>._current] !== <span class="hljs-string">"\""</span> &amp;&amp; <span class="hljs-keyword">this</span>._current &lt; maxLength) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-17" id="section-17"></a>
</div>
<p>You can escape a double quote and you can escape an escape.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">              <span class="hljs-keyword">var</span> current = <span class="hljs-keyword">this</span>._current;
              <span class="hljs-keyword">if</span> (stream[current] === <span class="hljs-string">"\\"</span> &amp;&amp; (stream[current + <span class="hljs-number">1</span>] === <span class="hljs-string">"\\"</span> ||
                                               stream[current + <span class="hljs-number">1</span>] === <span class="hljs-string">"\""</span>)) {
                  current += <span class="hljs-number">2</span>;
              } <span class="hljs-keyword">else</span> {
                  current++;
              }
              <span class="hljs-keyword">this</span>._current = current;
          }
          <span class="hljs-keyword">this</span>._current++;
          <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.parse(stream.slice(start, <span class="hljs-keyword">this</span>._current));
      },

      <span class="hljs-attr">_consumeRawStringLiteral</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">stream</span>) </span>{
          <span class="hljs-keyword">var</span> start = <span class="hljs-keyword">this</span>._current;
          <span class="hljs-keyword">this</span>._current++;
          <span class="hljs-keyword">var</span> maxLength = stream.length;
          <span class="hljs-keyword">while</span> (stream[<span class="hljs-keyword">this</span>._current] !== <span class="hljs-string">"'"</span> &amp;&amp; <span class="hljs-keyword">this</span>._current &lt; maxLength) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-18" id="section-18"></a>
</div>
<p>You can escape a single quote and you can escape an escape.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">              <span class="hljs-keyword">var</span> current = <span class="hljs-keyword">this</span>._current;
              <span class="hljs-keyword">if</span> (stream[current] === <span class="hljs-string">"\\"</span> &amp;&amp; (stream[current + <span class="hljs-number">1</span>] === <span class="hljs-string">"\\"</span> ||
                                               stream[current + <span class="hljs-number">1</span>] === <span class="hljs-string">"'"</span>)) {
                  current += <span class="hljs-number">2</span>;
              } <span class="hljs-keyword">else</span> {
                  current++;
              }
              <span class="hljs-keyword">this</span>._current = current;
          }
          <span class="hljs-keyword">this</span>._current++;
          <span class="hljs-keyword">var</span> literal = stream.slice(start + <span class="hljs-number">1</span>, <span class="hljs-keyword">this</span>._current - <span class="hljs-number">1</span>);
          <span class="hljs-keyword">return</span> literal.replace(<span class="hljs-string">"\\'"</span>, <span class="hljs-string">"'"</span>);
      },

      <span class="hljs-attr">_consumeNumber</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">stream</span>) </span>{
          <span class="hljs-keyword">var</span> start = <span class="hljs-keyword">this</span>._current;
          <span class="hljs-keyword">this</span>._current++;
          <span class="hljs-keyword">var</span> maxLength = stream.length;
          <span class="hljs-keyword">while</span> (isNum(stream[<span class="hljs-keyword">this</span>._current]) &amp;&amp; <span class="hljs-keyword">this</span>._current &lt; maxLength) {
              <span class="hljs-keyword">this</span>._current++;
          }
          <span class="hljs-keyword">var</span> value = <span class="hljs-built_in">parseInt</span>(stream.slice(start, <span class="hljs-keyword">this</span>._current));
          <span class="hljs-keyword">return</span> {<span class="hljs-attr">type</span>: TOK_NUMBER, <span class="hljs-attr">value</span>: value, <span class="hljs-attr">start</span>: start};
      },

      <span class="hljs-attr">_consumeLBracket</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">stream</span>) </span>{
          <span class="hljs-keyword">var</span> start = <span class="hljs-keyword">this</span>._current;
          <span class="hljs-keyword">this</span>._current++;
          <span class="hljs-keyword">if</span> (stream[<span class="hljs-keyword">this</span>._current] === <span class="hljs-string">"?"</span>) {
              <span class="hljs-keyword">this</span>._current++;
              <span class="hljs-keyword">return</span> {<span class="hljs-attr">type</span>: TOK_FILTER, <span class="hljs-attr">value</span>: <span class="hljs-string">"[?"</span>, <span class="hljs-attr">start</span>: start};
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (stream[<span class="hljs-keyword">this</span>._current] === <span class="hljs-string">"]"</span>) {
              <span class="hljs-keyword">this</span>._current++;
              <span class="hljs-keyword">return</span> {<span class="hljs-attr">type</span>: TOK_FLATTEN, <span class="hljs-attr">value</span>: <span class="hljs-string">"[]"</span>, <span class="hljs-attr">start</span>: start};
          } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">return</span> {<span class="hljs-attr">type</span>: TOK_LBRACKET, <span class="hljs-attr">value</span>: <span class="hljs-string">"["</span>, <span class="hljs-attr">start</span>: start};
          }
      },

      <span class="hljs-attr">_consumeOperator</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">stream</span>) </span>{
          <span class="hljs-keyword">var</span> start = <span class="hljs-keyword">this</span>._current;
          <span class="hljs-keyword">var</span> startingChar = stream[start];
          <span class="hljs-keyword">this</span>._current++;
          <span class="hljs-keyword">if</span> (startingChar === <span class="hljs-string">"!"</span>) {
              <span class="hljs-keyword">if</span> (stream[<span class="hljs-keyword">this</span>._current] === <span class="hljs-string">"="</span>) {
                  <span class="hljs-keyword">this</span>._current++;
                  <span class="hljs-keyword">return</span> {<span class="hljs-attr">type</span>: TOK_NE, <span class="hljs-attr">value</span>: <span class="hljs-string">"!="</span>, <span class="hljs-attr">start</span>: start};
              } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> {<span class="hljs-attr">type</span>: TOK_NOT, <span class="hljs-attr">value</span>: <span class="hljs-string">"!"</span>, <span class="hljs-attr">start</span>: start};
              }
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (startingChar === <span class="hljs-string">"&lt;"</span>) {
              <span class="hljs-keyword">if</span> (stream[<span class="hljs-keyword">this</span>._current] === <span class="hljs-string">"="</span>) {
                  <span class="hljs-keyword">this</span>._current++;
                  <span class="hljs-keyword">return</span> {<span class="hljs-attr">type</span>: TOK_LTE, <span class="hljs-attr">value</span>: <span class="hljs-string">"&lt;="</span>, <span class="hljs-attr">start</span>: start};
              } <span class="hljs-keyword">else</span> {
                  <span class="hljs-keyword">return</span> {<span class="hljs-attr">type</span>: TOK_LT, <span class="hljs-attr">value</span>: <span class="hljs-string">"&lt;"</span>, <span class="hljs-attr">start</span>: start};
              }
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (startingChar === <span class="hljs-string">"&gt;"</span>) {
              <span class="hljs-keyword">if</span> (stream[<span class="hljs-keyword">this</span>._current] === <span class="hljs-string">"="</span>) {
                  <span class="hljs-keyword">this</span>._current++;
                  <span class="hljs-keyword">return</span> {<span class="hljs-attr">type</span>: TOK_GTE, <span class="hljs-attr">value</span>: <span class="hljs-string">"&gt;="</span>, <span class="hljs-attr">start</span>: start};
              } <span class="hljs-keyword">else</span> {
                  <span class="hljs-keyword">return</span> {<span class="hljs-attr">type</span>: TOK_GT, <span class="hljs-attr">value</span>: <span class="hljs-string">"&gt;"</span>, <span class="hljs-attr">start</span>: start};
              }
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (startingChar === <span class="hljs-string">"="</span>) {
              <span class="hljs-keyword">if</span> (stream[<span class="hljs-keyword">this</span>._current] === <span class="hljs-string">"="</span>) {
                  <span class="hljs-keyword">this</span>._current++;
                  <span class="hljs-keyword">return</span> {<span class="hljs-attr">type</span>: TOK_EQ, <span class="hljs-attr">value</span>: <span class="hljs-string">"=="</span>, <span class="hljs-attr">start</span>: start};
              }
          }
      },

      <span class="hljs-attr">_consumeLiteral</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">stream</span>) </span>{
          <span class="hljs-keyword">this</span>._current++;
          <span class="hljs-keyword">var</span> start = <span class="hljs-keyword">this</span>._current;
          <span class="hljs-keyword">var</span> maxLength = stream.length;
          <span class="hljs-keyword">var</span> literal;
          <span class="hljs-keyword">while</span>(stream[<span class="hljs-keyword">this</span>._current] !== <span class="hljs-string">"`"</span> &amp;&amp; <span class="hljs-keyword">this</span>._current &lt; maxLength) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-19" id="section-19"></a>
</div>
<p>You can escape a literal char or you can escape the escape.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">              <span class="hljs-keyword">var</span> current = <span class="hljs-keyword">this</span>._current;
              <span class="hljs-keyword">if</span> (stream[current] === <span class="hljs-string">"\\"</span> &amp;&amp; (stream[current + <span class="hljs-number">1</span>] === <span class="hljs-string">"\\"</span> ||
                                               stream[current + <span class="hljs-number">1</span>] === <span class="hljs-string">"`"</span>)) {
                  current += <span class="hljs-number">2</span>;
              } <span class="hljs-keyword">else</span> {
                  current++;
              }
              <span class="hljs-keyword">this</span>._current = current;
          }
          <span class="hljs-keyword">var</span> literalString = trimLeft(stream.slice(start, <span class="hljs-keyword">this</span>._current));
          literalString = literalString.replace(<span class="hljs-string">"\\`"</span>, <span class="hljs-string">"`"</span>);
          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._looksLikeJSON(literalString)) {
              literal = <span class="hljs-built_in">JSON</span>.parse(literalString);
          } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-20" id="section-20"></a>
</div>
<p>Try to JSON parse it as &quot;<literal>&quot;</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">              literal = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-string">"\""</span> + literalString + <span class="hljs-string">"\""</span>);
          }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-21" id="section-21"></a>
</div>
<p>+1 gets us to the ending &quot;`&quot;, +1 to move on to the next char.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">this</span>._current++;
          <span class="hljs-keyword">return</span> literal;
      },

      <span class="hljs-attr">_looksLikeJSON</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">literalString</span>) </span>{
          <span class="hljs-keyword">var</span> startingChars = <span class="hljs-string">"[{\""</span>;
          <span class="hljs-keyword">var</span> jsonLiterals = [<span class="hljs-string">"true"</span>, <span class="hljs-string">"false"</span>, <span class="hljs-string">"null"</span>];
          <span class="hljs-keyword">var</span> numberLooking = <span class="hljs-string">"-0123456789"</span>;

          <span class="hljs-keyword">if</span> (literalString === <span class="hljs-string">""</span>) {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (startingChars.indexOf(literalString[<span class="hljs-number">0</span>]) &gt;= <span class="hljs-number">0</span>) {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (jsonLiterals.indexOf(literalString) &gt;= <span class="hljs-number">0</span>) {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (numberLooking.indexOf(literalString[<span class="hljs-number">0</span>]) &gt;= <span class="hljs-number">0</span>) {
              <span class="hljs-keyword">try</span> {
                  <span class="hljs-built_in">JSON</span>.parse(literalString);
                  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
              } <span class="hljs-keyword">catch</span> (ex) {
                  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
              }
          } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
          }
      }
  };

      <span class="hljs-keyword">var</span> bindingPower = {};
      bindingPower[TOK_EOF] = <span class="hljs-number">0</span>;
      bindingPower[TOK_UNQUOTEDIDENTIFIER] = <span class="hljs-number">0</span>;
      bindingPower[TOK_QUOTEDIDENTIFIER] = <span class="hljs-number">0</span>;
      bindingPower[TOK_RBRACKET] = <span class="hljs-number">0</span>;
      bindingPower[TOK_RPAREN] = <span class="hljs-number">0</span>;
      bindingPower[TOK_COMMA] = <span class="hljs-number">0</span>;
      bindingPower[TOK_RBRACE] = <span class="hljs-number">0</span>;
      bindingPower[TOK_NUMBER] = <span class="hljs-number">0</span>;
      bindingPower[TOK_CURRENT] = <span class="hljs-number">0</span>;
      bindingPower[TOK_EXPREF] = <span class="hljs-number">0</span>;
      bindingPower[TOK_PIPE] = <span class="hljs-number">1</span>;
      bindingPower[TOK_OR] = <span class="hljs-number">2</span>;
      bindingPower[TOK_AND] = <span class="hljs-number">3</span>;
      bindingPower[TOK_EQ] = <span class="hljs-number">5</span>;
      bindingPower[TOK_GT] = <span class="hljs-number">5</span>;
      bindingPower[TOK_LT] = <span class="hljs-number">5</span>;
      bindingPower[TOK_GTE] = <span class="hljs-number">5</span>;
      bindingPower[TOK_LTE] = <span class="hljs-number">5</span>;
      bindingPower[TOK_NE] = <span class="hljs-number">5</span>;
      bindingPower[TOK_FLATTEN] = <span class="hljs-number">9</span>;
      bindingPower[TOK_STAR] = <span class="hljs-number">20</span>;
      bindingPower[TOK_FILTER] = <span class="hljs-number">21</span>;
      bindingPower[TOK_DOT] = <span class="hljs-number">40</span>;
      bindingPower[TOK_NOT] = <span class="hljs-number">45</span>;
      bindingPower[TOK_LBRACE] = <span class="hljs-number">50</span>;
      bindingPower[TOK_LBRACKET] = <span class="hljs-number">55</span>;
      bindingPower[TOK_LPAREN] = <span class="hljs-number">60</span>;

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parser</span>(<span class="hljs-params"></span>) </span>{
  }

  Parser.prototype = {
      <span class="hljs-attr">parse</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">expression</span>) </span>{
          <span class="hljs-keyword">this</span>._loadTokens(expression);
          <span class="hljs-keyword">this</span>.index = <span class="hljs-number">0</span>;
          <span class="hljs-keyword">var</span> ast = <span class="hljs-keyword">this</span>.expression(<span class="hljs-number">0</span>);
          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._lookahead(<span class="hljs-number">0</span>) !== TOK_EOF) {
              <span class="hljs-keyword">var</span> t = <span class="hljs-keyword">this</span>._lookaheadToken(<span class="hljs-number">0</span>);
              <span class="hljs-keyword">var</span> error = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(
                  <span class="hljs-string">"Unexpected token type: "</span> + t.type + <span class="hljs-string">", value: "</span> + t.value);
              error.name = <span class="hljs-string">"ParserError"</span>;
              <span class="hljs-keyword">throw</span> error;
          }
          <span class="hljs-keyword">return</span> ast;
      },

      <span class="hljs-attr">_loadTokens</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">expression</span>) </span>{
          <span class="hljs-keyword">var</span> lexer = <span class="hljs-keyword">new</span> Lexer();
          <span class="hljs-keyword">var</span> tokens = lexer.tokenize(expression);
          tokens.push({<span class="hljs-attr">type</span>: TOK_EOF, <span class="hljs-attr">value</span>: <span class="hljs-string">""</span>, <span class="hljs-attr">start</span>: expression.length});
          <span class="hljs-keyword">this</span>.tokens = tokens;
      },

      <span class="hljs-attr">expression</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">rbp</span>) </span>{
          <span class="hljs-keyword">var</span> leftToken = <span class="hljs-keyword">this</span>._lookaheadToken(<span class="hljs-number">0</span>);
          <span class="hljs-keyword">this</span>._advance();
          <span class="hljs-keyword">var</span> left = <span class="hljs-keyword">this</span>.nud(leftToken);
          <span class="hljs-keyword">var</span> currentToken = <span class="hljs-keyword">this</span>._lookahead(<span class="hljs-number">0</span>);
          <span class="hljs-keyword">while</span> (rbp &lt; bindingPower[currentToken]) {
              <span class="hljs-keyword">this</span>._advance();
              left = <span class="hljs-keyword">this</span>.led(currentToken, left);
              currentToken = <span class="hljs-keyword">this</span>._lookahead(<span class="hljs-number">0</span>);
          }
          <span class="hljs-keyword">return</span> left;
      },

      <span class="hljs-attr">_lookahead</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">number</span>) </span>{
          <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.tokens[<span class="hljs-keyword">this</span>.index + number].type;
      },

      <span class="hljs-attr">_lookaheadToken</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">number</span>) </span>{
          <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.tokens[<span class="hljs-keyword">this</span>.index + number];
      },

      <span class="hljs-attr">_advance</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">this</span>.index++;
      },

      <span class="hljs-attr">nud</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">token</span>) </span>{
        <span class="hljs-keyword">var</span> left;
        <span class="hljs-keyword">var</span> right;
        <span class="hljs-keyword">var</span> expression;
        <span class="hljs-keyword">switch</span> (token.type) {
          <span class="hljs-keyword">case</span> TOK_LITERAL:
            <span class="hljs-keyword">return</span> {<span class="hljs-attr">type</span>: <span class="hljs-string">"Literal"</span>, <span class="hljs-attr">value</span>: token.value};
          <span class="hljs-keyword">case</span> TOK_UNQUOTEDIDENTIFIER:
            <span class="hljs-keyword">return</span> {<span class="hljs-attr">type</span>: <span class="hljs-string">"Field"</span>, <span class="hljs-attr">name</span>: token.value};
          <span class="hljs-keyword">case</span> TOK_QUOTEDIDENTIFIER:
            <span class="hljs-keyword">var</span> node = {<span class="hljs-attr">type</span>: <span class="hljs-string">"Field"</span>, <span class="hljs-attr">name</span>: token.value};
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._lookahead(<span class="hljs-number">0</span>) === TOK_LPAREN) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Quoted identifier not allowed for function names."</span>);
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> node;
            }
            <span class="hljs-keyword">break</span>;
          <span class="hljs-keyword">case</span> TOK_NOT:
            right = <span class="hljs-keyword">this</span>.expression(bindingPower.Not);
            <span class="hljs-keyword">return</span> {<span class="hljs-attr">type</span>: <span class="hljs-string">"NotExpression"</span>, <span class="hljs-attr">children</span>: [right]};
          <span class="hljs-keyword">case</span> TOK_STAR:
            left = {<span class="hljs-attr">type</span>: <span class="hljs-string">"Identity"</span>};
            right = <span class="hljs-literal">null</span>;
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._lookahead(<span class="hljs-number">0</span>) === TOK_RBRACKET) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-22" id="section-22"></a>
</div>
<p>This can happen in a multiselect,
[a, b, *]</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                right = {<span class="hljs-attr">type</span>: <span class="hljs-string">"Identity"</span>};
            } <span class="hljs-keyword">else</span> {
                right = <span class="hljs-keyword">this</span>._parseProjectionRHS(bindingPower.Star);
            }
            <span class="hljs-keyword">return</span> {<span class="hljs-attr">type</span>: <span class="hljs-string">"ValueProjection"</span>, <span class="hljs-attr">children</span>: [left, right]};
          <span class="hljs-keyword">case</span> TOK_FILTER:
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.led(token.type, {<span class="hljs-attr">type</span>: <span class="hljs-string">"Identity"</span>});
          <span class="hljs-keyword">case</span> TOK_LBRACE:
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._parseMultiselectHash();
          <span class="hljs-keyword">case</span> TOK_FLATTEN:
            left = {<span class="hljs-attr">type</span>: TOK_FLATTEN, <span class="hljs-attr">children</span>: [{<span class="hljs-attr">type</span>: <span class="hljs-string">"Identity"</span>}]};
            right = <span class="hljs-keyword">this</span>._parseProjectionRHS(bindingPower.Flatten);
            <span class="hljs-keyword">return</span> {<span class="hljs-attr">type</span>: <span class="hljs-string">"Projection"</span>, <span class="hljs-attr">children</span>: [left, right]};
          <span class="hljs-keyword">case</span> TOK_LBRACKET:
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._lookahead(<span class="hljs-number">0</span>) === TOK_NUMBER || <span class="hljs-keyword">this</span>._lookahead(<span class="hljs-number">0</span>) === TOK_COLON) {
                right = <span class="hljs-keyword">this</span>._parseIndexExpression();
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._projectIfSlice({<span class="hljs-attr">type</span>: <span class="hljs-string">"Identity"</span>}, right);
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._lookahead(<span class="hljs-number">0</span>) === TOK_STAR &amp;&amp;
                       <span class="hljs-keyword">this</span>._lookahead(<span class="hljs-number">1</span>) === TOK_RBRACKET) {
                <span class="hljs-keyword">this</span>._advance();
                <span class="hljs-keyword">this</span>._advance();
                right = <span class="hljs-keyword">this</span>._parseProjectionRHS(bindingPower.Star);
                <span class="hljs-keyword">return</span> {<span class="hljs-attr">type</span>: <span class="hljs-string">"Projection"</span>,
                        <span class="hljs-attr">children</span>: [{<span class="hljs-attr">type</span>: <span class="hljs-string">"Identity"</span>}, right]};
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._parseMultiselectList();
            }
            <span class="hljs-keyword">break</span>;
          <span class="hljs-keyword">case</span> TOK_CURRENT:
            <span class="hljs-keyword">return</span> {<span class="hljs-attr">type</span>: TOK_CURRENT};
          <span class="hljs-keyword">case</span> TOK_EXPREF:
            expression = <span class="hljs-keyword">this</span>.expression(bindingPower.Expref);
            <span class="hljs-keyword">return</span> {<span class="hljs-attr">type</span>: <span class="hljs-string">"ExpressionReference"</span>, <span class="hljs-attr">children</span>: [expression]};
          <span class="hljs-keyword">case</span> TOK_LPAREN:
            <span class="hljs-keyword">var</span> args = [];
            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>._lookahead(<span class="hljs-number">0</span>) !== TOK_RPAREN) {
              <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._lookahead(<span class="hljs-number">0</span>) === TOK_CURRENT) {
                expression = {<span class="hljs-attr">type</span>: TOK_CURRENT};
                <span class="hljs-keyword">this</span>._advance();
              } <span class="hljs-keyword">else</span> {
                expression = <span class="hljs-keyword">this</span>.expression(<span class="hljs-number">0</span>);
              }
              args.push(expression);
            }
            <span class="hljs-keyword">this</span>._match(TOK_RPAREN);
            <span class="hljs-keyword">return</span> args[<span class="hljs-number">0</span>];
          <span class="hljs-keyword">default</span>:
            <span class="hljs-keyword">this</span>._errorToken(token);
        }
      },

      <span class="hljs-attr">led</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">tokenName, left</span>) </span>{
        <span class="hljs-keyword">var</span> right;
        <span class="hljs-keyword">switch</span>(tokenName) {
          <span class="hljs-keyword">case</span> TOK_DOT:
            <span class="hljs-keyword">var</span> rbp = bindingPower.Dot;
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._lookahead(<span class="hljs-number">0</span>) !== TOK_STAR) {
                right = <span class="hljs-keyword">this</span>._parseDotRHS(rbp);
                <span class="hljs-keyword">return</span> {<span class="hljs-attr">type</span>: <span class="hljs-string">"Subexpression"</span>, <span class="hljs-attr">children</span>: [left, right]};
            } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-23" id="section-23"></a>
</div>
<p>Creating a projection.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                <span class="hljs-keyword">this</span>._advance();
                right = <span class="hljs-keyword">this</span>._parseProjectionRHS(rbp);
                <span class="hljs-keyword">return</span> {<span class="hljs-attr">type</span>: <span class="hljs-string">"ValueProjection"</span>, <span class="hljs-attr">children</span>: [left, right]};
            }
            <span class="hljs-keyword">break</span>;
          <span class="hljs-keyword">case</span> TOK_PIPE:
            right = <span class="hljs-keyword">this</span>.expression(bindingPower.Pipe);
            <span class="hljs-keyword">return</span> {<span class="hljs-attr">type</span>: TOK_PIPE, <span class="hljs-attr">children</span>: [left, right]};
          <span class="hljs-keyword">case</span> TOK_OR:
            right = <span class="hljs-keyword">this</span>.expression(bindingPower.Or);
            <span class="hljs-keyword">return</span> {<span class="hljs-attr">type</span>: <span class="hljs-string">"OrExpression"</span>, <span class="hljs-attr">children</span>: [left, right]};
          <span class="hljs-keyword">case</span> TOK_AND:
            right = <span class="hljs-keyword">this</span>.expression(bindingPower.And);
            <span class="hljs-keyword">return</span> {<span class="hljs-attr">type</span>: <span class="hljs-string">"AndExpression"</span>, <span class="hljs-attr">children</span>: [left, right]};
          <span class="hljs-keyword">case</span> TOK_LPAREN:
            <span class="hljs-keyword">var</span> name = left.name;
            <span class="hljs-keyword">var</span> args = [];
            <span class="hljs-keyword">var</span> expression, node;
            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>._lookahead(<span class="hljs-number">0</span>) !== TOK_RPAREN) {
              <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._lookahead(<span class="hljs-number">0</span>) === TOK_CURRENT) {
                expression = {<span class="hljs-attr">type</span>: TOK_CURRENT};
                <span class="hljs-keyword">this</span>._advance();
              } <span class="hljs-keyword">else</span> {
                expression = <span class="hljs-keyword">this</span>.expression(<span class="hljs-number">0</span>);
              }
              <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._lookahead(<span class="hljs-number">0</span>) === TOK_COMMA) {
                <span class="hljs-keyword">this</span>._match(TOK_COMMA);
              }
              args.push(expression);
            }
            <span class="hljs-keyword">this</span>._match(TOK_RPAREN);
            node = {<span class="hljs-attr">type</span>: <span class="hljs-string">"Function"</span>, <span class="hljs-attr">name</span>: name, <span class="hljs-attr">children</span>: args};
            <span class="hljs-keyword">return</span> node;
          <span class="hljs-keyword">case</span> TOK_FILTER:
            <span class="hljs-keyword">var</span> condition = <span class="hljs-keyword">this</span>.expression(<span class="hljs-number">0</span>);
            <span class="hljs-keyword">this</span>._match(TOK_RBRACKET);
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._lookahead(<span class="hljs-number">0</span>) === TOK_FLATTEN) {
              right = {<span class="hljs-attr">type</span>: <span class="hljs-string">"Identity"</span>};
            } <span class="hljs-keyword">else</span> {
              right = <span class="hljs-keyword">this</span>._parseProjectionRHS(bindingPower.Filter);
            }
            <span class="hljs-keyword">return</span> {<span class="hljs-attr">type</span>: <span class="hljs-string">"FilterProjection"</span>, <span class="hljs-attr">children</span>: [left, right, condition]};
          <span class="hljs-keyword">case</span> TOK_FLATTEN:
            <span class="hljs-keyword">var</span> leftNode = {<span class="hljs-attr">type</span>: TOK_FLATTEN, <span class="hljs-attr">children</span>: [left]};
            <span class="hljs-keyword">var</span> rightNode = <span class="hljs-keyword">this</span>._parseProjectionRHS(bindingPower.Flatten);
            <span class="hljs-keyword">return</span> {<span class="hljs-attr">type</span>: <span class="hljs-string">"Projection"</span>, <span class="hljs-attr">children</span>: [leftNode, rightNode]};
          <span class="hljs-keyword">case</span> TOK_EQ:
          <span class="hljs-keyword">case</span> TOK_NE:
          <span class="hljs-keyword">case</span> TOK_GT:
          <span class="hljs-keyword">case</span> TOK_GTE:
          <span class="hljs-keyword">case</span> TOK_LT:
          <span class="hljs-keyword">case</span> TOK_LTE:
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._parseComparator(left, tokenName);
          <span class="hljs-keyword">case</span> TOK_LBRACKET:
            <span class="hljs-keyword">var</span> token = <span class="hljs-keyword">this</span>._lookaheadToken(<span class="hljs-number">0</span>);
            <span class="hljs-keyword">if</span> (token.type === TOK_NUMBER || token.type === TOK_COLON) {
                right = <span class="hljs-keyword">this</span>._parseIndexExpression();
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._projectIfSlice(left, right);
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">this</span>._match(TOK_STAR);
                <span class="hljs-keyword">this</span>._match(TOK_RBRACKET);
                right = <span class="hljs-keyword">this</span>._parseProjectionRHS(bindingPower.Star);
                <span class="hljs-keyword">return</span> {<span class="hljs-attr">type</span>: <span class="hljs-string">"Projection"</span>, <span class="hljs-attr">children</span>: [left, right]};
            }
            <span class="hljs-keyword">break</span>;
          <span class="hljs-keyword">default</span>:
            <span class="hljs-keyword">this</span>._errorToken(<span class="hljs-keyword">this</span>._lookaheadToken(<span class="hljs-number">0</span>));
        }
      },

      <span class="hljs-attr">_match</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">tokenType</span>) </span>{
          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._lookahead(<span class="hljs-number">0</span>) === tokenType) {
              <span class="hljs-keyword">this</span>._advance();
          } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">var</span> t = <span class="hljs-keyword">this</span>._lookaheadToken(<span class="hljs-number">0</span>);
              <span class="hljs-keyword">var</span> error = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Expected "</span> + tokenType + <span class="hljs-string">", got: "</span> + t.type);
              error.name = <span class="hljs-string">"ParserError"</span>;
              <span class="hljs-keyword">throw</span> error;
          }
      },

      <span class="hljs-attr">_errorToken</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">token</span>) </span>{
          <span class="hljs-keyword">var</span> error = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Invalid token ("</span> +
                                token.type + <span class="hljs-string">"): \""</span> +
                                token.value + <span class="hljs-string">"\""</span>);
          error.name = <span class="hljs-string">"ParserError"</span>;
          <span class="hljs-keyword">throw</span> error;
      },


      <span class="hljs-attr">_parseIndexExpression</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._lookahead(<span class="hljs-number">0</span>) === TOK_COLON || <span class="hljs-keyword">this</span>._lookahead(<span class="hljs-number">1</span>) === TOK_COLON) {
              <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._parseSliceExpression();
          } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">var</span> node = {
                  <span class="hljs-attr">type</span>: <span class="hljs-string">"Index"</span>,
                  <span class="hljs-attr">value</span>: <span class="hljs-keyword">this</span>._lookaheadToken(<span class="hljs-number">0</span>).value};
              <span class="hljs-keyword">this</span>._advance();
              <span class="hljs-keyword">this</span>._match(TOK_RBRACKET);
              <span class="hljs-keyword">return</span> node;
          }
      },

      <span class="hljs-attr">_projectIfSlice</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">left, right</span>) </span>{
          <span class="hljs-keyword">var</span> indexExpr = {<span class="hljs-attr">type</span>: <span class="hljs-string">"IndexExpression"</span>, <span class="hljs-attr">children</span>: [left, right]};
          <span class="hljs-keyword">if</span> (right.type === <span class="hljs-string">"Slice"</span>) {
              <span class="hljs-keyword">return</span> {
                  <span class="hljs-attr">type</span>: <span class="hljs-string">"Projection"</span>,
                  <span class="hljs-attr">children</span>: [indexExpr, <span class="hljs-keyword">this</span>._parseProjectionRHS(bindingPower.Star)]
              };
          } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">return</span> indexExpr;
          }
      },

      <span class="hljs-attr">_parseSliceExpression</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-24" id="section-24"></a>
</div>
<p>[start:end:step] where each part is optional, as well as the last
colon.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">var</span> parts = [<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>];
          <span class="hljs-keyword">var</span> index = <span class="hljs-number">0</span>;
          <span class="hljs-keyword">var</span> currentToken = <span class="hljs-keyword">this</span>._lookahead(<span class="hljs-number">0</span>);
          <span class="hljs-keyword">while</span> (currentToken !== TOK_RBRACKET &amp;&amp; index &lt; <span class="hljs-number">3</span>) {
              <span class="hljs-keyword">if</span> (currentToken === TOK_COLON) {
                  index++;
                  <span class="hljs-keyword">this</span>._advance();
              } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (currentToken === TOK_NUMBER) {
                  parts[index] = <span class="hljs-keyword">this</span>._lookaheadToken(<span class="hljs-number">0</span>).value;
                  <span class="hljs-keyword">this</span>._advance();
              } <span class="hljs-keyword">else</span> {
                  <span class="hljs-keyword">var</span> t = <span class="hljs-keyword">this</span>._lookahead(<span class="hljs-number">0</span>);
                  <span class="hljs-keyword">var</span> error = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Syntax error, unexpected token: "</span> +
                                        t.value + <span class="hljs-string">"("</span> + t.type + <span class="hljs-string">")"</span>);
                  error.name = <span class="hljs-string">"Parsererror"</span>;
                  <span class="hljs-keyword">throw</span> error;
              }
              currentToken = <span class="hljs-keyword">this</span>._lookahead(<span class="hljs-number">0</span>);
          }
          <span class="hljs-keyword">this</span>._match(TOK_RBRACKET);
          <span class="hljs-keyword">return</span> {
              <span class="hljs-attr">type</span>: <span class="hljs-string">"Slice"</span>,
              <span class="hljs-attr">children</span>: parts
          };
      },

      <span class="hljs-attr">_parseComparator</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">left, comparator</span>) </span>{
        <span class="hljs-keyword">var</span> right = <span class="hljs-keyword">this</span>.expression(bindingPower[comparator]);
        <span class="hljs-keyword">return</span> {<span class="hljs-attr">type</span>: <span class="hljs-string">"Comparator"</span>, <span class="hljs-attr">name</span>: comparator, <span class="hljs-attr">children</span>: [left, right]};
      },

      <span class="hljs-attr">_parseDotRHS</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">rbp</span>) </span>{
          <span class="hljs-keyword">var</span> lookahead = <span class="hljs-keyword">this</span>._lookahead(<span class="hljs-number">0</span>);
          <span class="hljs-keyword">var</span> exprTokens = [TOK_UNQUOTEDIDENTIFIER, TOK_QUOTEDIDENTIFIER, TOK_STAR];
          <span class="hljs-keyword">if</span> (exprTokens.indexOf(lookahead) &gt;= <span class="hljs-number">0</span>) {
              <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.expression(rbp);
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (lookahead === TOK_LBRACKET) {
              <span class="hljs-keyword">this</span>._match(TOK_LBRACKET);
              <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._parseMultiselectList();
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (lookahead === TOK_LBRACE) {
              <span class="hljs-keyword">this</span>._match(TOK_LBRACE);
              <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._parseMultiselectHash();
          }
      },

      <span class="hljs-attr">_parseProjectionRHS</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">rbp</span>) </span>{
          <span class="hljs-keyword">var</span> right;
          <span class="hljs-keyword">if</span> (bindingPower[<span class="hljs-keyword">this</span>._lookahead(<span class="hljs-number">0</span>)] &lt; <span class="hljs-number">10</span>) {
              right = {<span class="hljs-attr">type</span>: <span class="hljs-string">"Identity"</span>};
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._lookahead(<span class="hljs-number">0</span>) === TOK_LBRACKET) {
              right = <span class="hljs-keyword">this</span>.expression(rbp);
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._lookahead(<span class="hljs-number">0</span>) === TOK_FILTER) {
              right = <span class="hljs-keyword">this</span>.expression(rbp);
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._lookahead(<span class="hljs-number">0</span>) === TOK_DOT) {
              <span class="hljs-keyword">this</span>._match(TOK_DOT);
              right = <span class="hljs-keyword">this</span>._parseDotRHS(rbp);
          } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">var</span> t = <span class="hljs-keyword">this</span>._lookaheadToken(<span class="hljs-number">0</span>);
              <span class="hljs-keyword">var</span> error = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Sytanx error, unexpected token: "</span> +
                                    t.value + <span class="hljs-string">"("</span> + t.type + <span class="hljs-string">")"</span>);
              error.name = <span class="hljs-string">"ParserError"</span>;
              <span class="hljs-keyword">throw</span> error;
          }
          <span class="hljs-keyword">return</span> right;
      },

      <span class="hljs-attr">_parseMultiselectList</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">var</span> expressions = [];
          <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>._lookahead(<span class="hljs-number">0</span>) !== TOK_RBRACKET) {
              <span class="hljs-keyword">var</span> expression = <span class="hljs-keyword">this</span>.expression(<span class="hljs-number">0</span>);
              expressions.push(expression);
              <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._lookahead(<span class="hljs-number">0</span>) === TOK_COMMA) {
                  <span class="hljs-keyword">this</span>._match(TOK_COMMA);
                  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._lookahead(<span class="hljs-number">0</span>) === TOK_RBRACKET) {
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Unexpected token Rbracket"</span>);
                  }
              }
          }
          <span class="hljs-keyword">this</span>._match(TOK_RBRACKET);
          <span class="hljs-keyword">return</span> {<span class="hljs-attr">type</span>: <span class="hljs-string">"MultiSelectList"</span>, <span class="hljs-attr">children</span>: expressions};
      },

      <span class="hljs-attr">_parseMultiselectHash</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> pairs = [];
        <span class="hljs-keyword">var</span> identifierTypes = [TOK_UNQUOTEDIDENTIFIER, TOK_QUOTEDIDENTIFIER];
        <span class="hljs-keyword">var</span> keyToken, keyName, value, node;
        <span class="hljs-keyword">for</span> (;;) {
          keyToken = <span class="hljs-keyword">this</span>._lookaheadToken(<span class="hljs-number">0</span>);
          <span class="hljs-keyword">if</span> (identifierTypes.indexOf(keyToken.type) &lt; <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Expecting an identifier token, got: "</span> +
                            keyToken.type);
          }
          keyName = keyToken.value;
          <span class="hljs-keyword">this</span>._advance();
          <span class="hljs-keyword">this</span>._match(TOK_COLON);
          value = <span class="hljs-keyword">this</span>.expression(<span class="hljs-number">0</span>);
          node = {<span class="hljs-attr">type</span>: <span class="hljs-string">"KeyValuePair"</span>, <span class="hljs-attr">name</span>: keyName, <span class="hljs-attr">value</span>: value};
          pairs.push(node);
          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._lookahead(<span class="hljs-number">0</span>) === TOK_COMMA) {
            <span class="hljs-keyword">this</span>._match(TOK_COMMA);
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._lookahead(<span class="hljs-number">0</span>) === TOK_RBRACE) {
            <span class="hljs-keyword">this</span>._match(TOK_RBRACE);
            <span class="hljs-keyword">break</span>;
          }
        }
        <span class="hljs-keyword">return</span> {<span class="hljs-attr">type</span>: <span class="hljs-string">"MultiSelectHash"</span>, <span class="hljs-attr">children</span>: pairs};
      }
  };


  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">TreeInterpreter</span>(<span class="hljs-params">runtime</span>) </span>{
    <span class="hljs-keyword">this</span>.runtime = runtime;
  }

  TreeInterpreter.prototype = {
      <span class="hljs-attr">search</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node, value</span>) </span>{
          <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.visit(node, value);
      },

      <span class="hljs-attr">visit</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node, value</span>) </span>{
          <span class="hljs-keyword">var</span> matched, current, result, first, second, field, left, right, collected, i;
          <span class="hljs-keyword">switch</span> (node.type) {
            <span class="hljs-keyword">case</span> <span class="hljs-string">"Field"</span>:
              <span class="hljs-keyword">if</span> (value === <span class="hljs-literal">null</span> ) {
                  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
              } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isObject(value)) {
                  field = value[node.name];
                  <span class="hljs-keyword">if</span> (field === <span class="hljs-literal">undefined</span>) {
                      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
                  } <span class="hljs-keyword">else</span> {
                      <span class="hljs-keyword">return</span> field;
                  }
              } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
              }
              <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> <span class="hljs-string">"Subexpression"</span>:
              result = <span class="hljs-keyword">this</span>.visit(node.children[<span class="hljs-number">0</span>], value);
              <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; node.children.length; i++) {
                  result = <span class="hljs-keyword">this</span>.visit(node.children[<span class="hljs-number">1</span>], result);
                  <span class="hljs-keyword">if</span> (result === <span class="hljs-literal">null</span>) {
                      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
                  }
              }
              <span class="hljs-keyword">return</span> result;
            <span class="hljs-keyword">case</span> <span class="hljs-string">"IndexExpression"</span>:
              left = <span class="hljs-keyword">this</span>.visit(node.children[<span class="hljs-number">0</span>], value);
              right = <span class="hljs-keyword">this</span>.visit(node.children[<span class="hljs-number">1</span>], left);
              <span class="hljs-keyword">return</span> right;
            <span class="hljs-keyword">case</span> <span class="hljs-string">"Index"</span>:
              <span class="hljs-keyword">if</span> (!isArray(value)) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
              }
              <span class="hljs-keyword">var</span> index = node.value;
              <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span>) {
                index = value.length + index;
              }
              result = value[index];
              <span class="hljs-keyword">if</span> (result === <span class="hljs-literal">undefined</span>) {
                result = <span class="hljs-literal">null</span>;
              }
              <span class="hljs-keyword">return</span> result;
            <span class="hljs-keyword">case</span> <span class="hljs-string">"Slice"</span>:
              <span class="hljs-keyword">if</span> (!isArray(value)) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
              }
              <span class="hljs-keyword">var</span> sliceParams = node.children.slice(<span class="hljs-number">0</span>);
              <span class="hljs-keyword">var</span> computed = <span class="hljs-keyword">this</span>.computeSliceParams(value.length, sliceParams);
              <span class="hljs-keyword">var</span> start = computed[<span class="hljs-number">0</span>];
              <span class="hljs-keyword">var</span> stop = computed[<span class="hljs-number">1</span>];
              <span class="hljs-keyword">var</span> step = computed[<span class="hljs-number">2</span>];
              result = [];
              <span class="hljs-keyword">if</span> (step &gt; <span class="hljs-number">0</span>) {
                  <span class="hljs-keyword">for</span> (i = start; i &lt; stop; i += step) {
                      result.push(value[i]);
                  }
              } <span class="hljs-keyword">else</span> {
                  <span class="hljs-keyword">for</span> (i = start; i &gt; stop; i += step) {
                      result.push(value[i]);
                  }
              }
              <span class="hljs-keyword">return</span> result;
            <span class="hljs-keyword">case</span> <span class="hljs-string">"Projection"</span>:
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-25" id="section-25"></a>
</div>
<p>Evaluate left child.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">              <span class="hljs-keyword">var</span> base = <span class="hljs-keyword">this</span>.visit(node.children[<span class="hljs-number">0</span>], value);
              <span class="hljs-keyword">if</span> (!isArray(base)) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
              }
              collected = [];
              <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; base.length; i++) {
                current = <span class="hljs-keyword">this</span>.visit(node.children[<span class="hljs-number">1</span>], base[i]);
                <span class="hljs-keyword">if</span> (current !== <span class="hljs-literal">null</span>) {
                  collected.push(current);
                }
              }
              <span class="hljs-keyword">return</span> collected;
            <span class="hljs-keyword">case</span> <span class="hljs-string">"ValueProjection"</span>:
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-26" id="section-26"></a>
</div>
<p>Evaluate left child.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">              base = <span class="hljs-keyword">this</span>.visit(node.children[<span class="hljs-number">0</span>], value);
              <span class="hljs-keyword">if</span> (!isObject(base)) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
              }
              collected = [];
              <span class="hljs-keyword">var</span> values = objValues(base);
              <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; values.length; i++) {
                current = <span class="hljs-keyword">this</span>.visit(node.children[<span class="hljs-number">1</span>], values[i]);
                <span class="hljs-keyword">if</span> (current !== <span class="hljs-literal">null</span>) {
                  collected.push(current);
                }
              }
              <span class="hljs-keyword">return</span> collected;
            <span class="hljs-keyword">case</span> <span class="hljs-string">"FilterProjection"</span>:
              base = <span class="hljs-keyword">this</span>.visit(node.children[<span class="hljs-number">0</span>], value);
              <span class="hljs-keyword">if</span> (!isArray(base)) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
              }
              <span class="hljs-keyword">var</span> filtered = [];
              <span class="hljs-keyword">var</span> finalResults = [];
              <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; base.length; i++) {
                matched = <span class="hljs-keyword">this</span>.visit(node.children[<span class="hljs-number">2</span>], base[i]);
                <span class="hljs-keyword">if</span> (!isFalse(matched)) {
                  filtered.push(base[i]);
                }
              }
              <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; filtered.length; j++) {
                current = <span class="hljs-keyword">this</span>.visit(node.children[<span class="hljs-number">1</span>], filtered[j]);
                <span class="hljs-keyword">if</span> (current !== <span class="hljs-literal">null</span>) {
                  finalResults.push(current);
                }
              }
              <span class="hljs-keyword">return</span> finalResults;
            <span class="hljs-keyword">case</span> <span class="hljs-string">"Comparator"</span>:
              first = <span class="hljs-keyword">this</span>.visit(node.children[<span class="hljs-number">0</span>], value);
              second = <span class="hljs-keyword">this</span>.visit(node.children[<span class="hljs-number">1</span>], value);
              <span class="hljs-keyword">switch</span>(node.name) {
                <span class="hljs-keyword">case</span> TOK_EQ:
                  result = strictDeepEqual(first, second);
                  <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> TOK_NE:
                  result = !strictDeepEqual(first, second);
                  <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> TOK_GT:
                  result = first &gt; second;
                  <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> TOK_GTE:
                  result = first &gt;= second;
                  <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> TOK_LT:
                  result = first &lt; second;
                  <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> TOK_LTE:
                  result = first &lt;= second;
                  <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">default</span>:
                  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Unknown comparator: "</span> + node.name);
              }
              <span class="hljs-keyword">return</span> result;
            <span class="hljs-keyword">case</span> TOK_FLATTEN:
              <span class="hljs-keyword">var</span> original = <span class="hljs-keyword">this</span>.visit(node.children[<span class="hljs-number">0</span>], value);
              <span class="hljs-keyword">if</span> (!isArray(original)) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
              }
              <span class="hljs-keyword">var</span> merged = [];
              <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; original.length; i++) {
                current = original[i];
                <span class="hljs-keyword">if</span> (isArray(current)) {
                  merged.push.apply(merged, current);
                } <span class="hljs-keyword">else</span> {
                  merged.push(current);
                }
              }
              <span class="hljs-keyword">return</span> merged;
            <span class="hljs-keyword">case</span> <span class="hljs-string">"Identity"</span>:
              <span class="hljs-keyword">return</span> value;
            <span class="hljs-keyword">case</span> <span class="hljs-string">"MultiSelectList"</span>:
              <span class="hljs-keyword">if</span> (value === <span class="hljs-literal">null</span>) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
              }
              collected = [];
              <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; node.children.length; i++) {
                  collected.push(<span class="hljs-keyword">this</span>.visit(node.children[i], value));
              }
              <span class="hljs-keyword">return</span> collected;
            <span class="hljs-keyword">case</span> <span class="hljs-string">"MultiSelectHash"</span>:
              <span class="hljs-keyword">if</span> (value === <span class="hljs-literal">null</span>) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
              }
              collected = {};
              <span class="hljs-keyword">var</span> child;
              <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; node.children.length; i++) {
                child = node.children[i];
                collected[child.name] = <span class="hljs-keyword">this</span>.visit(child.value, value);
              }
              <span class="hljs-keyword">return</span> collected;
            <span class="hljs-keyword">case</span> <span class="hljs-string">"OrExpression"</span>:
              matched = <span class="hljs-keyword">this</span>.visit(node.children[<span class="hljs-number">0</span>], value);
              <span class="hljs-keyword">if</span> (isFalse(matched)) {
                  matched = <span class="hljs-keyword">this</span>.visit(node.children[<span class="hljs-number">1</span>], value);
              }
              <span class="hljs-keyword">return</span> matched;
            <span class="hljs-keyword">case</span> <span class="hljs-string">"AndExpression"</span>:
              first = <span class="hljs-keyword">this</span>.visit(node.children[<span class="hljs-number">0</span>], value);

              <span class="hljs-keyword">if</span> (isFalse(first) === <span class="hljs-literal">true</span>) {
                <span class="hljs-keyword">return</span> first;
              }
              <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.visit(node.children[<span class="hljs-number">1</span>], value);
            <span class="hljs-keyword">case</span> <span class="hljs-string">"NotExpression"</span>:
              first = <span class="hljs-keyword">this</span>.visit(node.children[<span class="hljs-number">0</span>], value);
              <span class="hljs-keyword">return</span> isFalse(first);
            <span class="hljs-keyword">case</span> <span class="hljs-string">"Literal"</span>:
              <span class="hljs-keyword">return</span> node.value;
            <span class="hljs-keyword">case</span> TOK_PIPE:
              left = <span class="hljs-keyword">this</span>.visit(node.children[<span class="hljs-number">0</span>], value);
              <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.visit(node.children[<span class="hljs-number">1</span>], left);
            <span class="hljs-keyword">case</span> TOK_CURRENT:
              <span class="hljs-keyword">return</span> value;
            <span class="hljs-keyword">case</span> <span class="hljs-string">"Function"</span>:
              <span class="hljs-keyword">var</span> resolvedArgs = [];
              <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; node.children.length; i++) {
                  resolvedArgs.push(<span class="hljs-keyword">this</span>.visit(node.children[i], value));
              }
              <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.runtime.callFunction(node.name, resolvedArgs);
            <span class="hljs-keyword">case</span> <span class="hljs-string">"ExpressionReference"</span>:
              <span class="hljs-keyword">var</span> refNode = node.children[<span class="hljs-number">0</span>];
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-27" id="section-27"></a>
</div>
<p>Tag the node with a specific attribute so the type
checker verify the type.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">              refNode.jmespathType = TOK_EXPREF;
              <span class="hljs-keyword">return</span> refNode;
            <span class="hljs-keyword">default</span>:
              <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Unknown node type: "</span> + node.type);
          }
      },

      <span class="hljs-attr">computeSliceParams</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">arrayLength, sliceParams</span>) </span>{
        <span class="hljs-keyword">var</span> start = sliceParams[<span class="hljs-number">0</span>];
        <span class="hljs-keyword">var</span> stop = sliceParams[<span class="hljs-number">1</span>];
        <span class="hljs-keyword">var</span> step = sliceParams[<span class="hljs-number">2</span>];
        <span class="hljs-keyword">var</span> computed = [<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>];
        <span class="hljs-keyword">if</span> (step === <span class="hljs-literal">null</span>) {
          step = <span class="hljs-number">1</span>;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (step === <span class="hljs-number">0</span>) {
          <span class="hljs-keyword">var</span> error = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Invalid slice, step cannot be 0"</span>);
          error.name = <span class="hljs-string">"RuntimeError"</span>;
          <span class="hljs-keyword">throw</span> error;
        }
        <span class="hljs-keyword">var</span> stepValueNegative = step &lt; <span class="hljs-number">0</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;

        <span class="hljs-keyword">if</span> (start === <span class="hljs-literal">null</span>) {
            start = stepValueNegative ? arrayLength - <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;
        } <span class="hljs-keyword">else</span> {
            start = <span class="hljs-keyword">this</span>.capSliceRange(arrayLength, start, step);
        }

        <span class="hljs-keyword">if</span> (stop === <span class="hljs-literal">null</span>) {
            stop = stepValueNegative ? <span class="hljs-number">-1</span> : arrayLength;
        } <span class="hljs-keyword">else</span> {
            stop = <span class="hljs-keyword">this</span>.capSliceRange(arrayLength, stop, step);
        }
        computed[<span class="hljs-number">0</span>] = start;
        computed[<span class="hljs-number">1</span>] = stop;
        computed[<span class="hljs-number">2</span>] = step;
        <span class="hljs-keyword">return</span> computed;
      },

      <span class="hljs-attr">capSliceRange</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">arrayLength, actualValue, step</span>) </span>{
          <span class="hljs-keyword">if</span> (actualValue &lt; <span class="hljs-number">0</span>) {
              actualValue += arrayLength;
              <span class="hljs-keyword">if</span> (actualValue &lt; <span class="hljs-number">0</span>) {
                  actualValue = step &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">-1</span> : <span class="hljs-number">0</span>;
              }
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (actualValue &gt;= arrayLength) {
              actualValue = step &lt; <span class="hljs-number">0</span> ? arrayLength - <span class="hljs-number">1</span> : arrayLength;
          }
          <span class="hljs-keyword">return</span> actualValue;
      }

  };

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Runtime</span>(<span class="hljs-params">interpreter</span>) </span>{
    <span class="hljs-keyword">this</span>._interpreter = interpreter;
    <span class="hljs-keyword">this</span>.functionTable = {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-28" id="section-28"></a>
</div>
<p>name: [function, <signature>]
The <signature> can be:</p>
<p>{
args: [[type1, type2], [type1, type2]],
variadic: true|false
}</p>
<p>Each arg in the arg list is a list of valid types
(if the function is overloaded and supports multiple
types.  If the type is &quot;any&quot; then no type checking
occurs on the argument.  Variadic is optional
and if not provided is assumed to be false.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        abs: {<span class="hljs-attr">_func</span>: <span class="hljs-keyword">this</span>._functionAbs, <span class="hljs-attr">_signature</span>: [{<span class="hljs-attr">types</span>: [TYPE_NUMBER]}]},
        <span class="hljs-attr">avg</span>: {<span class="hljs-attr">_func</span>: <span class="hljs-keyword">this</span>._functionAvg, <span class="hljs-attr">_signature</span>: [{<span class="hljs-attr">types</span>: [TYPE_ARRAY_NUMBER]}]},
        <span class="hljs-attr">ceil</span>: {<span class="hljs-attr">_func</span>: <span class="hljs-keyword">this</span>._functionCeil, <span class="hljs-attr">_signature</span>: [{<span class="hljs-attr">types</span>: [TYPE_NUMBER]}]},
        <span class="hljs-attr">contains</span>: {
            <span class="hljs-attr">_func</span>: <span class="hljs-keyword">this</span>._functionContains,
            <span class="hljs-attr">_signature</span>: [{<span class="hljs-attr">types</span>: [TYPE_STRING, TYPE_ARRAY]},
                        {<span class="hljs-attr">types</span>: [TYPE_ANY]}]},
        <span class="hljs-string">"ends_with"</span>: {
            <span class="hljs-attr">_func</span>: <span class="hljs-keyword">this</span>._functionEndsWith,
            <span class="hljs-attr">_signature</span>: [{<span class="hljs-attr">types</span>: [TYPE_STRING]}, {<span class="hljs-attr">types</span>: [TYPE_STRING]}]},
        <span class="hljs-attr">floor</span>: {<span class="hljs-attr">_func</span>: <span class="hljs-keyword">this</span>._functionFloor, <span class="hljs-attr">_signature</span>: [{<span class="hljs-attr">types</span>: [TYPE_NUMBER]}]},
        <span class="hljs-attr">length</span>: {
            <span class="hljs-attr">_func</span>: <span class="hljs-keyword">this</span>._functionLength,
            <span class="hljs-attr">_signature</span>: [{<span class="hljs-attr">types</span>: [TYPE_STRING, TYPE_ARRAY, TYPE_OBJECT]}]},
        <span class="hljs-attr">map</span>: {
            <span class="hljs-attr">_func</span>: <span class="hljs-keyword">this</span>._functionMap,
            <span class="hljs-attr">_signature</span>: [{<span class="hljs-attr">types</span>: [TYPE_EXPREF]}, {<span class="hljs-attr">types</span>: [TYPE_ARRAY]}]},
        <span class="hljs-attr">max</span>: {
            <span class="hljs-attr">_func</span>: <span class="hljs-keyword">this</span>._functionMax,
            <span class="hljs-attr">_signature</span>: [{<span class="hljs-attr">types</span>: [TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING]}]},
        <span class="hljs-string">"merge"</span>: {
            <span class="hljs-attr">_func</span>: <span class="hljs-keyword">this</span>._functionMerge,
            <span class="hljs-attr">_signature</span>: [{<span class="hljs-attr">types</span>: [TYPE_OBJECT], <span class="hljs-attr">variadic</span>: <span class="hljs-literal">true</span>}]
        },
        <span class="hljs-string">"max_by"</span>: {
          <span class="hljs-attr">_func</span>: <span class="hljs-keyword">this</span>._functionMaxBy,
          <span class="hljs-attr">_signature</span>: [{<span class="hljs-attr">types</span>: [TYPE_ARRAY]}, {<span class="hljs-attr">types</span>: [TYPE_EXPREF]}]
        },
        <span class="hljs-attr">sum</span>: {<span class="hljs-attr">_func</span>: <span class="hljs-keyword">this</span>._functionSum, <span class="hljs-attr">_signature</span>: [{<span class="hljs-attr">types</span>: [TYPE_ARRAY_NUMBER]}]},
        <span class="hljs-string">"starts_with"</span>: {
            <span class="hljs-attr">_func</span>: <span class="hljs-keyword">this</span>._functionStartsWith,
            <span class="hljs-attr">_signature</span>: [{<span class="hljs-attr">types</span>: [TYPE_STRING]}, {<span class="hljs-attr">types</span>: [TYPE_STRING]}]},
        <span class="hljs-attr">min</span>: {
            <span class="hljs-attr">_func</span>: <span class="hljs-keyword">this</span>._functionMin,
            <span class="hljs-attr">_signature</span>: [{<span class="hljs-attr">types</span>: [TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING]}]},
        <span class="hljs-string">"min_by"</span>: {
          <span class="hljs-attr">_func</span>: <span class="hljs-keyword">this</span>._functionMinBy,
          <span class="hljs-attr">_signature</span>: [{<span class="hljs-attr">types</span>: [TYPE_ARRAY]}, {<span class="hljs-attr">types</span>: [TYPE_EXPREF]}]
        },
        <span class="hljs-attr">type</span>: {<span class="hljs-attr">_func</span>: <span class="hljs-keyword">this</span>._functionType, <span class="hljs-attr">_signature</span>: [{<span class="hljs-attr">types</span>: [TYPE_ANY]}]},
        <span class="hljs-attr">keys</span>: {<span class="hljs-attr">_func</span>: <span class="hljs-keyword">this</span>._functionKeys, <span class="hljs-attr">_signature</span>: [{<span class="hljs-attr">types</span>: [TYPE_OBJECT]}]},
        <span class="hljs-attr">values</span>: {<span class="hljs-attr">_func</span>: <span class="hljs-keyword">this</span>._functionValues, <span class="hljs-attr">_signature</span>: [{<span class="hljs-attr">types</span>: [TYPE_OBJECT]}]},
        <span class="hljs-attr">sort</span>: {<span class="hljs-attr">_func</span>: <span class="hljs-keyword">this</span>._functionSort, <span class="hljs-attr">_signature</span>: [{<span class="hljs-attr">types</span>: [TYPE_ARRAY_STRING, TYPE_ARRAY_NUMBER]}]},
        <span class="hljs-string">"sort_by"</span>: {
          <span class="hljs-attr">_func</span>: <span class="hljs-keyword">this</span>._functionSortBy,
          <span class="hljs-attr">_signature</span>: [{<span class="hljs-attr">types</span>: [TYPE_ARRAY]}, {<span class="hljs-attr">types</span>: [TYPE_EXPREF]}]
        },
        <span class="hljs-attr">join</span>: {
            <span class="hljs-attr">_func</span>: <span class="hljs-keyword">this</span>._functionJoin,
            <span class="hljs-attr">_signature</span>: [
                {<span class="hljs-attr">types</span>: [TYPE_STRING]},
                {<span class="hljs-attr">types</span>: [TYPE_ARRAY_STRING]}
            ]
        },
        <span class="hljs-attr">reverse</span>: {
            <span class="hljs-attr">_func</span>: <span class="hljs-keyword">this</span>._functionReverse,
            <span class="hljs-attr">_signature</span>: [{<span class="hljs-attr">types</span>: [TYPE_STRING, TYPE_ARRAY]}]},
        <span class="hljs-string">"to_array"</span>: {<span class="hljs-attr">_func</span>: <span class="hljs-keyword">this</span>._functionToArray, <span class="hljs-attr">_signature</span>: [{<span class="hljs-attr">types</span>: [TYPE_ANY]}]},
        <span class="hljs-string">"to_string"</span>: {<span class="hljs-attr">_func</span>: <span class="hljs-keyword">this</span>._functionToString, <span class="hljs-attr">_signature</span>: [{<span class="hljs-attr">types</span>: [TYPE_ANY]}]},
        <span class="hljs-string">"to_number"</span>: {<span class="hljs-attr">_func</span>: <span class="hljs-keyword">this</span>._functionToNumber, <span class="hljs-attr">_signature</span>: [{<span class="hljs-attr">types</span>: [TYPE_ANY]}]},
        <span class="hljs-string">"not_null"</span>: {
            <span class="hljs-attr">_func</span>: <span class="hljs-keyword">this</span>._functionNotNull,
            <span class="hljs-attr">_signature</span>: [{<span class="hljs-attr">types</span>: [TYPE_ANY], <span class="hljs-attr">variadic</span>: <span class="hljs-literal">true</span>}]
        }
    };
  }

  Runtime.prototype = {
    <span class="hljs-attr">callFunction</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name, resolvedArgs</span>) </span>{
      <span class="hljs-keyword">var</span> functionEntry = <span class="hljs-keyword">this</span>.functionTable[name];
      <span class="hljs-keyword">if</span> (functionEntry === <span class="hljs-literal">undefined</span>) {
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Unknown function: "</span> + name + <span class="hljs-string">"()"</span>);
      }
      <span class="hljs-keyword">this</span>._validateArgs(name, resolvedArgs, functionEntry._signature);
      <span class="hljs-keyword">return</span> functionEntry._func.call(<span class="hljs-keyword">this</span>, resolvedArgs);
    },

    <span class="hljs-attr">_validateArgs</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name, args, signature</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-29" id="section-29"></a>
</div>
<p>Validating the args requires validating
the correct arity and the correct type of each arg.
If the last argument is declared as variadic, then we need
a minimum number of args to be required.  Otherwise it has to
be an exact amount.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">var</span> pluralized;
        <span class="hljs-keyword">if</span> (signature[signature.length - <span class="hljs-number">1</span>].variadic) {
            <span class="hljs-keyword">if</span> (args.length &lt; signature.length) {
                pluralized = signature.length === <span class="hljs-number">1</span> ? <span class="hljs-string">" argument"</span> : <span class="hljs-string">" arguments"</span>;
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"ArgumentError: "</span> + name + <span class="hljs-string">"() "</span> +
                                <span class="hljs-string">"takes at least"</span> + signature.length + pluralized +
                                <span class="hljs-string">" but received "</span> + args.length);
            }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (args.length !== signature.length) {
            pluralized = signature.length === <span class="hljs-number">1</span> ? <span class="hljs-string">" argument"</span> : <span class="hljs-string">" arguments"</span>;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"ArgumentError: "</span> + name + <span class="hljs-string">"() "</span> +
                            <span class="hljs-string">"takes "</span> + signature.length + pluralized +
                            <span class="hljs-string">" but received "</span> + args.length);
        }
        <span class="hljs-keyword">var</span> currentSpec;
        <span class="hljs-keyword">var</span> actualType;
        <span class="hljs-keyword">var</span> typeMatched;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; signature.length; i++) {
            typeMatched = <span class="hljs-literal">false</span>;
            currentSpec = signature[i].types;
            actualType = <span class="hljs-keyword">this</span>._getTypeName(args[i]);
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; currentSpec.length; j++) {
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._typeMatches(actualType, currentSpec[j], args[i])) {
                    typeMatched = <span class="hljs-literal">true</span>;
                    <span class="hljs-keyword">break</span>;
                }
            }
            <span class="hljs-keyword">if</span> (!typeMatched) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"TypeError: "</span> + name + <span class="hljs-string">"() "</span> +
                                <span class="hljs-string">"expected argument "</span> + (i + <span class="hljs-number">1</span>) +
                                <span class="hljs-string">" to be type "</span> + currentSpec +
                                <span class="hljs-string">" but received type "</span> + actualType +
                                <span class="hljs-string">" instead."</span>);
            }
        }
    },

    <span class="hljs-attr">_typeMatches</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">actual, expected, argValue</span>) </span>{
        <span class="hljs-keyword">if</span> (expected === TYPE_ANY) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }
        <span class="hljs-keyword">if</span> (expected === TYPE_ARRAY_STRING ||
            expected === TYPE_ARRAY_NUMBER ||
            expected === TYPE_ARRAY) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-30" id="section-30"></a>
</div>
<p>The expected type can either just be array,
or it can require a specific subtype (array of numbers).</p>
<p>The simplest case is if &quot;array&quot; with no subtype is specified.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">if</span> (expected === TYPE_ARRAY) {
                <span class="hljs-keyword">return</span> actual === TYPE_ARRAY;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (actual === TYPE_ARRAY) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-31" id="section-31"></a>
</div>
<p>Otherwise we need to check subtypes.
I think this has potential to be improved.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                <span class="hljs-keyword">var</span> subtype;
                <span class="hljs-keyword">if</span> (expected === TYPE_ARRAY_NUMBER) {
                  subtype = TYPE_NUMBER;
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (expected === TYPE_ARRAY_STRING) {
                  subtype = TYPE_STRING;
                }
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; argValue.length; i++) {
                    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>._typeMatches(
                            <span class="hljs-keyword">this</span>._getTypeName(argValue[i]), subtype,
                                             argValue[i])) {
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                    }
                }
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            }
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> actual === expected;
        }
    },
    <span class="hljs-attr">_getTypeName</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">obj</span>) </span>{
        <span class="hljs-keyword">switch</span> (<span class="hljs-built_in">Object</span>.prototype.toString.call(obj)) {
            <span class="hljs-keyword">case</span> <span class="hljs-string">"[object String]"</span>:
              <span class="hljs-keyword">return</span> TYPE_STRING;
            <span class="hljs-keyword">case</span> <span class="hljs-string">"[object Number]"</span>:
              <span class="hljs-keyword">return</span> TYPE_NUMBER;
            <span class="hljs-keyword">case</span> <span class="hljs-string">"[object Array]"</span>:
              <span class="hljs-keyword">return</span> TYPE_ARRAY;
            <span class="hljs-keyword">case</span> <span class="hljs-string">"[object Boolean]"</span>:
              <span class="hljs-keyword">return</span> TYPE_BOOLEAN;
            <span class="hljs-keyword">case</span> <span class="hljs-string">"[object Null]"</span>:
              <span class="hljs-keyword">return</span> TYPE_NULL;
            <span class="hljs-keyword">case</span> <span class="hljs-string">"[object Object]"</span>:
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-32" id="section-32"></a>
</div>
<p>Check if it's an expref.  If it has, it's been
tagged with a jmespathType attr of 'Expref';</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">              <span class="hljs-keyword">if</span> (obj.jmespathType === TOK_EXPREF) {
                <span class="hljs-keyword">return</span> TYPE_EXPREF;
              } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> TYPE_OBJECT;
              }
        }
    },

    <span class="hljs-attr">_functionStartsWith</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolvedArgs</span>) </span>{
        <span class="hljs-keyword">return</span> resolvedArgs[<span class="hljs-number">0</span>].lastIndexOf(resolvedArgs[<span class="hljs-number">1</span>]) === <span class="hljs-number">0</span>;
    },

    <span class="hljs-attr">_functionEndsWith</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolvedArgs</span>) </span>{
        <span class="hljs-keyword">var</span> searchStr = resolvedArgs[<span class="hljs-number">0</span>];
        <span class="hljs-keyword">var</span> suffix = resolvedArgs[<span class="hljs-number">1</span>];
        <span class="hljs-keyword">return</span> searchStr.indexOf(suffix, searchStr.length - suffix.length) !== <span class="hljs-number">-1</span>;
    },

    <span class="hljs-attr">_functionReverse</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolvedArgs</span>) </span>{
        <span class="hljs-keyword">var</span> typeName = <span class="hljs-keyword">this</span>._getTypeName(resolvedArgs[<span class="hljs-number">0</span>]);
        <span class="hljs-keyword">if</span> (typeName === TYPE_STRING) {
          <span class="hljs-keyword">var</span> originalStr = resolvedArgs[<span class="hljs-number">0</span>];
          <span class="hljs-keyword">var</span> reversedStr = <span class="hljs-string">""</span>;
          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = originalStr.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {
              reversedStr += originalStr[i];
          }
          <span class="hljs-keyword">return</span> reversedStr;
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">var</span> reversedArray = resolvedArgs[<span class="hljs-number">0</span>].slice(<span class="hljs-number">0</span>);
          reversedArray.reverse();
          <span class="hljs-keyword">return</span> reversedArray;
        }
    },

    <span class="hljs-attr">_functionAbs</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolvedArgs</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.abs(resolvedArgs[<span class="hljs-number">0</span>]);
    },

    <span class="hljs-attr">_functionCeil</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolvedArgs</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.ceil(resolvedArgs[<span class="hljs-number">0</span>]);
    },

    <span class="hljs-attr">_functionAvg</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolvedArgs</span>) </span>{
        <span class="hljs-keyword">var</span> sum = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">var</span> inputArray = resolvedArgs[<span class="hljs-number">0</span>];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; inputArray.length; i++) {
            sum += inputArray[i];
        }
        <span class="hljs-keyword">return</span> sum / inputArray.length;
    },

    <span class="hljs-attr">_functionContains</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolvedArgs</span>) </span>{
        <span class="hljs-keyword">return</span> resolvedArgs[<span class="hljs-number">0</span>].indexOf(resolvedArgs[<span class="hljs-number">1</span>]) &gt;= <span class="hljs-number">0</span>;
    },

    <span class="hljs-attr">_functionFloor</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolvedArgs</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.floor(resolvedArgs[<span class="hljs-number">0</span>]);
    },

    <span class="hljs-attr">_functionLength</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolvedArgs</span>) </span>{
       <span class="hljs-keyword">if</span> (!isObject(resolvedArgs[<span class="hljs-number">0</span>])) {
         <span class="hljs-keyword">return</span> resolvedArgs[<span class="hljs-number">0</span>].length;
       } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-33" id="section-33"></a>
</div>
<p>As far as I can tell, there's no way to get the length
of an object without O(n) iteration through the object.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">         <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.keys(resolvedArgs[<span class="hljs-number">0</span>]).length;
       }
    },

    <span class="hljs-attr">_functionMap</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolvedArgs</span>) </span>{
      <span class="hljs-keyword">var</span> mapped = [];
      <span class="hljs-keyword">var</span> interpreter = <span class="hljs-keyword">this</span>._interpreter;
      <span class="hljs-keyword">var</span> exprefNode = resolvedArgs[<span class="hljs-number">0</span>];
      <span class="hljs-keyword">var</span> elements = resolvedArgs[<span class="hljs-number">1</span>];
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; elements.length; i++) {
          mapped.push(interpreter.visit(exprefNode, elements[i]));
      }
      <span class="hljs-keyword">return</span> mapped;
    },

    <span class="hljs-attr">_functionMerge</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolvedArgs</span>) </span>{
      <span class="hljs-keyword">var</span> merged = {};
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; resolvedArgs.length; i++) {
        <span class="hljs-keyword">var</span> current = resolvedArgs[i];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> current) {
          merged[key] = current[key];
        }
      }
      <span class="hljs-keyword">return</span> merged;
    },

    <span class="hljs-attr">_functionMax</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolvedArgs</span>) </span>{
      <span class="hljs-keyword">if</span> (resolvedArgs[<span class="hljs-number">0</span>].length &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">var</span> typeName = <span class="hljs-keyword">this</span>._getTypeName(resolvedArgs[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]);
        <span class="hljs-keyword">if</span> (typeName === TYPE_NUMBER) {
          <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.max.apply(<span class="hljs-built_in">Math</span>, resolvedArgs[<span class="hljs-number">0</span>]);
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">var</span> elements = resolvedArgs[<span class="hljs-number">0</span>];
          <span class="hljs-keyword">var</span> maxElement = elements[<span class="hljs-number">0</span>];
          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; elements.length; i++) {
              <span class="hljs-keyword">if</span> (maxElement.localeCompare(elements[i]) &lt; <span class="hljs-number">0</span>) {
                  maxElement = elements[i];
              }
          }
          <span class="hljs-keyword">return</span> maxElement;
        }
      } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }
    },

    <span class="hljs-attr">_functionMin</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolvedArgs</span>) </span>{
      <span class="hljs-keyword">if</span> (resolvedArgs[<span class="hljs-number">0</span>].length &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">var</span> typeName = <span class="hljs-keyword">this</span>._getTypeName(resolvedArgs[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]);
        <span class="hljs-keyword">if</span> (typeName === TYPE_NUMBER) {
          <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.min.apply(<span class="hljs-built_in">Math</span>, resolvedArgs[<span class="hljs-number">0</span>]);
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">var</span> elements = resolvedArgs[<span class="hljs-number">0</span>];
          <span class="hljs-keyword">var</span> minElement = elements[<span class="hljs-number">0</span>];
          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; elements.length; i++) {
              <span class="hljs-keyword">if</span> (elements[i].localeCompare(minElement) &lt; <span class="hljs-number">0</span>) {
                  minElement = elements[i];
              }
          }
          <span class="hljs-keyword">return</span> minElement;
        }
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }
    },

    <span class="hljs-attr">_functionSum</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolvedArgs</span>) </span>{
      <span class="hljs-keyword">var</span> sum = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">var</span> listToSum = resolvedArgs[<span class="hljs-number">0</span>];
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; listToSum.length; i++) {
        sum += listToSum[i];
      }
      <span class="hljs-keyword">return</span> sum;
    },

    <span class="hljs-attr">_functionType</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolvedArgs</span>) </span>{
        <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">this</span>._getTypeName(resolvedArgs[<span class="hljs-number">0</span>])) {
          <span class="hljs-keyword">case</span> TYPE_NUMBER:
            <span class="hljs-keyword">return</span> <span class="hljs-string">"number"</span>;
          <span class="hljs-keyword">case</span> TYPE_STRING:
            <span class="hljs-keyword">return</span> <span class="hljs-string">"string"</span>;
          <span class="hljs-keyword">case</span> TYPE_ARRAY:
            <span class="hljs-keyword">return</span> <span class="hljs-string">"array"</span>;
          <span class="hljs-keyword">case</span> TYPE_OBJECT:
            <span class="hljs-keyword">return</span> <span class="hljs-string">"object"</span>;
          <span class="hljs-keyword">case</span> TYPE_BOOLEAN:
            <span class="hljs-keyword">return</span> <span class="hljs-string">"boolean"</span>;
          <span class="hljs-keyword">case</span> TYPE_EXPREF:
            <span class="hljs-keyword">return</span> <span class="hljs-string">"expref"</span>;
          <span class="hljs-keyword">case</span> TYPE_NULL:
            <span class="hljs-keyword">return</span> <span class="hljs-string">"null"</span>;
        }
    },

    <span class="hljs-attr">_functionKeys</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolvedArgs</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.keys(resolvedArgs[<span class="hljs-number">0</span>]);
    },

    <span class="hljs-attr">_functionValues</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolvedArgs</span>) </span>{
        <span class="hljs-keyword">var</span> obj = resolvedArgs[<span class="hljs-number">0</span>];
        <span class="hljs-keyword">var</span> keys = <span class="hljs-built_in">Object</span>.keys(obj);
        <span class="hljs-keyword">var</span> values = [];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; keys.length; i++) {
            values.push(obj[keys[i]]);
        }
        <span class="hljs-keyword">return</span> values;
    },

    <span class="hljs-attr">_functionJoin</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolvedArgs</span>) </span>{
        <span class="hljs-keyword">var</span> joinChar = resolvedArgs[<span class="hljs-number">0</span>];
        <span class="hljs-keyword">var</span> listJoin = resolvedArgs[<span class="hljs-number">1</span>];
        <span class="hljs-keyword">return</span> listJoin.join(joinChar);
    },

    <span class="hljs-attr">_functionToArray</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolvedArgs</span>) </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._getTypeName(resolvedArgs[<span class="hljs-number">0</span>]) === TYPE_ARRAY) {
            <span class="hljs-keyword">return</span> resolvedArgs[<span class="hljs-number">0</span>];
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> [resolvedArgs[<span class="hljs-number">0</span>]];
        }
    },

    <span class="hljs-attr">_functionToString</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolvedArgs</span>) </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._getTypeName(resolvedArgs[<span class="hljs-number">0</span>]) === TYPE_STRING) {
            <span class="hljs-keyword">return</span> resolvedArgs[<span class="hljs-number">0</span>];
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.stringify(resolvedArgs[<span class="hljs-number">0</span>]);
        }
    },

    <span class="hljs-attr">_functionToNumber</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolvedArgs</span>) </span>{
        <span class="hljs-keyword">var</span> typeName = <span class="hljs-keyword">this</span>._getTypeName(resolvedArgs[<span class="hljs-number">0</span>]);
        <span class="hljs-keyword">var</span> convertedValue;
        <span class="hljs-keyword">if</span> (typeName === TYPE_NUMBER) {
            <span class="hljs-keyword">return</span> resolvedArgs[<span class="hljs-number">0</span>];
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (typeName === TYPE_STRING) {
            convertedValue = +resolvedArgs[<span class="hljs-number">0</span>];
            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isNaN</span>(convertedValue)) {
                <span class="hljs-keyword">return</span> convertedValue;
            }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    },

    <span class="hljs-attr">_functionNotNull</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolvedArgs</span>) </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; resolvedArgs.length; i++) {
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._getTypeName(resolvedArgs[i]) !== TYPE_NULL) {
                <span class="hljs-keyword">return</span> resolvedArgs[i];
            }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    },

    <span class="hljs-attr">_functionSort</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolvedArgs</span>) </span>{
        <span class="hljs-keyword">var</span> sortedArray = resolvedArgs[<span class="hljs-number">0</span>].slice(<span class="hljs-number">0</span>);
        sortedArray.sort();
        <span class="hljs-keyword">return</span> sortedArray;
    },

    <span class="hljs-attr">_functionSortBy</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolvedArgs</span>) </span>{
        <span class="hljs-keyword">var</span> sortedArray = resolvedArgs[<span class="hljs-number">0</span>].slice(<span class="hljs-number">0</span>);
        <span class="hljs-keyword">if</span> (sortedArray.length === <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> sortedArray;
        }
        <span class="hljs-keyword">var</span> interpreter = <span class="hljs-keyword">this</span>._interpreter;
        <span class="hljs-keyword">var</span> exprefNode = resolvedArgs[<span class="hljs-number">1</span>];
        <span class="hljs-keyword">var</span> requiredType = <span class="hljs-keyword">this</span>._getTypeName(
            interpreter.visit(exprefNode, sortedArray[<span class="hljs-number">0</span>]));
        <span class="hljs-keyword">if</span> ([TYPE_NUMBER, TYPE_STRING].indexOf(requiredType) &lt; <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"TypeError"</span>);
        }
        <span class="hljs-keyword">var</span> that = <span class="hljs-keyword">this</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-34" id="section-34"></a>
</div>
<p>In order to get a stable sort out of an unstable
sort algorithm, we decorate/sort/undecorate (DSU)
by creating a new list of [index, element] pairs.
In the cmp function, if the evaluated elements are
equal, then the index will be used as the tiebreaker.
After the decorated list has been sorted, it will be
undecorated to extract the original elements.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">var</span> decorated = [];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; sortedArray.length; i++) {
          decorated.push([i, sortedArray[i]]);
        }
        decorated.sort(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) </span>{
          <span class="hljs-keyword">var</span> exprA = interpreter.visit(exprefNode, a[<span class="hljs-number">1</span>]);
          <span class="hljs-keyword">var</span> exprB = interpreter.visit(exprefNode, b[<span class="hljs-number">1</span>]);
          <span class="hljs-keyword">if</span> (that._getTypeName(exprA) !== requiredType) {
              <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(
                  <span class="hljs-string">"TypeError: expected "</span> + requiredType + <span class="hljs-string">", received "</span> +
                  that._getTypeName(exprA));
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (that._getTypeName(exprB) !== requiredType) {
              <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(
                  <span class="hljs-string">"TypeError: expected "</span> + requiredType + <span class="hljs-string">", received "</span> +
                  that._getTypeName(exprB));
          }
          <span class="hljs-keyword">if</span> (exprA &gt; exprB) {
            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (exprA &lt; exprB) {
            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
          } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-35" id="section-35"></a>
</div>
<p>If they're equal compare the items by their
order to maintain relative order of equal keys
(i.e. to get a stable sort).</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>];
          }
        });
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-36" id="section-36"></a>
</div>
<p>Undecorate: extract out the original list elements.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; decorated.length; j++) {
          sortedArray[j] = decorated[j][<span class="hljs-number">1</span>];
        }
        <span class="hljs-keyword">return</span> sortedArray;
    },

    <span class="hljs-attr">_functionMaxBy</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolvedArgs</span>) </span>{
      <span class="hljs-keyword">var</span> exprefNode = resolvedArgs[<span class="hljs-number">1</span>];
      <span class="hljs-keyword">var</span> resolvedArray = resolvedArgs[<span class="hljs-number">0</span>];
      <span class="hljs-keyword">var</span> keyFunction = <span class="hljs-keyword">this</span>.createKeyFunction(exprefNode, [TYPE_NUMBER, TYPE_STRING]);
      <span class="hljs-keyword">var</span> maxNumber = -<span class="hljs-literal">Infinity</span>;
      <span class="hljs-keyword">var</span> maxRecord;
      <span class="hljs-keyword">var</span> current;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; resolvedArray.length; i++) {
        current = keyFunction(resolvedArray[i]);
        <span class="hljs-keyword">if</span> (current &gt; maxNumber) {
          maxNumber = current;
          maxRecord = resolvedArray[i];
        }
      }
      <span class="hljs-keyword">return</span> maxRecord;
    },

    <span class="hljs-attr">_functionMinBy</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolvedArgs</span>) </span>{
      <span class="hljs-keyword">var</span> exprefNode = resolvedArgs[<span class="hljs-number">1</span>];
      <span class="hljs-keyword">var</span> resolvedArray = resolvedArgs[<span class="hljs-number">0</span>];
      <span class="hljs-keyword">var</span> keyFunction = <span class="hljs-keyword">this</span>.createKeyFunction(exprefNode, [TYPE_NUMBER, TYPE_STRING]);
      <span class="hljs-keyword">var</span> minNumber = <span class="hljs-literal">Infinity</span>;
      <span class="hljs-keyword">var</span> minRecord;
      <span class="hljs-keyword">var</span> current;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; resolvedArray.length; i++) {
        current = keyFunction(resolvedArray[i]);
        <span class="hljs-keyword">if</span> (current &lt; minNumber) {
          minNumber = current;
          minRecord = resolvedArray[i];
        }
      }
      <span class="hljs-keyword">return</span> minRecord;
    },

    <span class="hljs-attr">createKeyFunction</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">exprefNode, allowedTypes</span>) </span>{
      <span class="hljs-keyword">var</span> that = <span class="hljs-keyword">this</span>;
      <span class="hljs-keyword">var</span> interpreter = <span class="hljs-keyword">this</span>._interpreter;
      <span class="hljs-keyword">var</span> keyFunc = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) </span>{
        <span class="hljs-keyword">var</span> current = interpreter.visit(exprefNode, x);
        <span class="hljs-keyword">if</span> (allowedTypes.indexOf(that._getTypeName(current)) &lt; <span class="hljs-number">0</span>) {
          <span class="hljs-keyword">var</span> msg = <span class="hljs-string">"TypeError: expected one of "</span> + allowedTypes +
                    <span class="hljs-string">", received "</span> + that._getTypeName(current);
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(msg);
        }
        <span class="hljs-keyword">return</span> current;
      };
      <span class="hljs-keyword">return</span> keyFunc;
    }

  };

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compile</span>(<span class="hljs-params">stream</span>) </span>{
    <span class="hljs-keyword">var</span> parser = <span class="hljs-keyword">new</span> Parser();
    <span class="hljs-keyword">var</span> ast = parser.parse(stream);
    <span class="hljs-keyword">return</span> ast;
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tokenize</span>(<span class="hljs-params">stream</span>) </span>{
      <span class="hljs-keyword">var</span> lexer = <span class="hljs-keyword">new</span> Lexer();
      <span class="hljs-keyword">return</span> lexer.tokenize(stream);
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">search</span>(<span class="hljs-params">data, expression</span>) </span>{
      <span class="hljs-keyword">var</span> parser = <span class="hljs-keyword">new</span> Parser();
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-37" id="section-37"></a>
</div>
<p>This needs to be improved.  Both the interpreter and runtime depend on
each other.  The runtime needs the interpreter to support exprefs.
There's likely a clean way to avoid the cyclic dependency.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">var</span> runtime = <span class="hljs-keyword">new</span> Runtime();
      <span class="hljs-keyword">var</span> interpreter = <span class="hljs-keyword">new</span> TreeInterpreter(runtime);
      runtime._interpreter = interpreter;
      <span class="hljs-keyword">var</span> node = parser.parse(expression);
      <span class="hljs-keyword">return</span> interpreter.search(node, data);
  }

  exports.tokenize = tokenize;
  exports.compile = compile;
  exports.search = search;
  exports.strictDeepEqual = strictDeepEqual;
})(<span class="hljs-keyword">typeof</span> exports === <span class="hljs-string">"undefined"</span> ? <span class="hljs-keyword">this</span>.jmespath = {} : exports);

</pre>
        </td>
      </tr>
    
  </tbody>
</table>

  </div>
</body>
</html>
