<!DOCTYPE html>
<html>
<head>
  <title>minimatch.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="../../doc-style.css" />
  <script src="../../doc-filelist.js"></script>
  <script>
    var relativeDir = "../../";
    var thisFile = "node_modules\\minimatch\\minimatch.js";
    var defaultSidebar = true;
  </script>
  <script src="../../doc-script.js"></script>

</head>
<body>
  <div id="sidebar_wrapper">
    <div id="sidebar_switch">
      <span class="tree">Files</span>
      <span class="headings">Headings</span>
    </div>
    <div id="tree"></div>
    <div id="headings">

    </div>
  </div>
  <div id="sidebar-toggle"></div>
  <div id="container">
    <div class="background highlight"></div>
<table cellpadding="0" cellspacing="0">
  <tbody>
    
      <tr>
        <td class="docs">
          <h1>minimatch.js</h1>
        </td>
        <td class="code highlight"></td>
      </tr>
    
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1" id="section-1"></a>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-built_in">module</span>.exports = minimatch
minimatch.Minimatch = Minimatch

<span class="hljs-keyword">var</span> path = { <span class="hljs-attr">sep</span>: <span class="hljs-string">'/'</span> }
<span class="hljs-keyword">try</span> {
  path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>)
} <span class="hljs-keyword">catch</span> (er) {}

<span class="hljs-keyword">var</span> GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}
<span class="hljs-keyword">var</span> expand = <span class="hljs-built_in">require</span>(<span class="hljs-string">'brace-expansion'</span>)

<span class="hljs-keyword">var</span> plTypes = {
  <span class="hljs-string">'!'</span>: { <span class="hljs-attr">open</span>: <span class="hljs-string">'(?:(?!(?:'</span>, <span class="hljs-attr">close</span>: <span class="hljs-string">'))[^/]*?)'</span>},
  <span class="hljs-string">'?'</span>: { <span class="hljs-attr">open</span>: <span class="hljs-string">'(?:'</span>, <span class="hljs-attr">close</span>: <span class="hljs-string">')?'</span> },
  <span class="hljs-string">'+'</span>: { <span class="hljs-attr">open</span>: <span class="hljs-string">'(?:'</span>, <span class="hljs-attr">close</span>: <span class="hljs-string">')+'</span> },
  <span class="hljs-string">'*'</span>: { <span class="hljs-attr">open</span>: <span class="hljs-string">'(?:'</span>, <span class="hljs-attr">close</span>: <span class="hljs-string">')*'</span> },
  <span class="hljs-string">'@'</span>: { <span class="hljs-attr">open</span>: <span class="hljs-string">'(?:'</span>, <span class="hljs-attr">close</span>: <span class="hljs-string">')'</span> }
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-2" id="section-2"></a>
</div>
<p>any single thing other than /
don't need to escape / when using new RegExp()</p>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-keyword">var</span> qmark = <span class="hljs-string">'[^/]'</span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-3" id="section-3"></a>
</div>
<ul>
<li>=&gt; any number of characters</li>
</ul>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-keyword">var</span> star = qmark + <span class="hljs-string">'*?'</span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-4" id="section-4"></a>
</div>
<p>** when dots are allowed.  Anything goes, except .. and .
not (^ or / followed by one or two dots followed by $ or /),
followed by anything, any number of times.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-keyword">var</span> twoStarDot = <span class="hljs-string">'(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?'</span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-5" id="section-5"></a>
</div>
<p>not a ^ or / followed by a dot,
followed by anything, any number of times.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-keyword">var</span> twoStarNoDot = <span class="hljs-string">'(?:(?!(?:\\\/|^)\\.).)*?'</span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-6" id="section-6"></a>
</div>
<p>characters that need to be escaped in RegExp.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-keyword">var</span> reSpecials = charSet(<span class="hljs-string">'().*{}+?[]^$\\!'</span>)

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-7" id="section-7"></a>
</div>
<p>&quot;abc&quot; -&gt; { a:true, b:true, c:true }</p>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">charSet</span> (<span class="hljs-params">s</span>) </span>{
  <span class="hljs-keyword">return</span> s.split(<span class="hljs-string">''</span>).reduce(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">set, c</span>) </span>{
    set[c] = <span class="hljs-literal">true</span>
    <span class="hljs-keyword">return</span> set
  }, {})
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-8" id="section-8"></a>
</div>
<p>normalizes slashes.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-keyword">var</span> slashSplit = <span class="hljs-regexp">/\/+/</span>

minimatch.filter = filter
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">filter</span> (<span class="hljs-params">pattern, options</span>) </span>{
  options = options || {}
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">p, i, list</span>) </span>{
    <span class="hljs-keyword">return</span> minimatch(p, pattern, options)
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ext</span> (<span class="hljs-params">a, b</span>) </span>{
  a = a || {}
  b = b || {}
  <span class="hljs-keyword">var</span> t = {}
  <span class="hljs-built_in">Object</span>.keys(b).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">k</span>) </span>{
    t[k] = b[k]
  })
  <span class="hljs-built_in">Object</span>.keys(a).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">k</span>) </span>{
    t[k] = a[k]
  })
  <span class="hljs-keyword">return</span> t
}

minimatch.defaults = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">def</span>) </span>{
  <span class="hljs-keyword">if</span> (!def || !<span class="hljs-built_in">Object</span>.keys(def).length) <span class="hljs-keyword">return</span> minimatch

  <span class="hljs-keyword">var</span> orig = minimatch

  <span class="hljs-keyword">var</span> m = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">minimatch</span> (<span class="hljs-params">p, pattern, options</span>) </span>{
    <span class="hljs-keyword">return</span> orig.minimatch(p, pattern, ext(def, options))
  }

  m.Minimatch = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Minimatch</span> (<span class="hljs-params">pattern, options</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> orig.Minimatch(pattern, ext(def, options))
  }

  <span class="hljs-keyword">return</span> m
}

Minimatch.defaults = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">def</span>) </span>{
  <span class="hljs-keyword">if</span> (!def || !<span class="hljs-built_in">Object</span>.keys(def).length) <span class="hljs-keyword">return</span> Minimatch
  <span class="hljs-keyword">return</span> minimatch.defaults(def).Minimatch
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">minimatch</span> (<span class="hljs-params">p, pattern, options</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> pattern !== <span class="hljs-string">'string'</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">'glob pattern string required'</span>)
  }

  <span class="hljs-keyword">if</span> (!options) options = {}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-9" id="section-9"></a>
</div>
<p>shortcut: comments match nothing.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-keyword">if</span> (!options.nocomment &amp;&amp; pattern.charAt(<span class="hljs-number">0</span>) === <span class="hljs-string">'#'</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
  }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-10" id="section-10"></a>
</div>
<p>&quot;&quot; only matches &quot;&quot;</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-keyword">if</span> (pattern.trim() === <span class="hljs-string">''</span>) <span class="hljs-keyword">return</span> p === <span class="hljs-string">''</span>

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Minimatch(pattern, options).match(p)
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Minimatch</span> (<span class="hljs-params">pattern, options</span>) </span>{
  <span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> Minimatch)) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Minimatch(pattern, options)
  }

  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> pattern !== <span class="hljs-string">'string'</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">'glob pattern string required'</span>)
  }

  <span class="hljs-keyword">if</span> (!options) options = {}
  pattern = pattern.trim()

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-11" id="section-11"></a>
</div>
<p>windows support: need to use /, not \</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-keyword">if</span> (path.sep !== <span class="hljs-string">'/'</span>) {
    pattern = pattern.split(path.sep).join(<span class="hljs-string">'/'</span>)
  }

  <span class="hljs-keyword">this</span>.options = options
  <span class="hljs-keyword">this</span>.set = []
  <span class="hljs-keyword">this</span>.pattern = pattern
  <span class="hljs-keyword">this</span>.regexp = <span class="hljs-literal">null</span>
  <span class="hljs-keyword">this</span>.negate = <span class="hljs-literal">false</span>
  <span class="hljs-keyword">this</span>.comment = <span class="hljs-literal">false</span>
  <span class="hljs-keyword">this</span>.empty = <span class="hljs-literal">false</span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-12" id="section-12"></a>
</div>
<p>make the set of regexps etc.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-keyword">this</span>.make()
}

Minimatch.prototype.debug = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{}

Minimatch.prototype.make = make
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">make</span> (<span class="hljs-params"></span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-13" id="section-13"></a>
</div>
<p>don't do it more than once.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._made) <span class="hljs-keyword">return</span>

  <span class="hljs-keyword">var</span> pattern = <span class="hljs-keyword">this</span>.pattern
  <span class="hljs-keyword">var</span> options = <span class="hljs-keyword">this</span>.options

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-14" id="section-14"></a>
</div>
<p>empty patterns and comments match nothing.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-keyword">if</span> (!options.nocomment &amp;&amp; pattern.charAt(<span class="hljs-number">0</span>) === <span class="hljs-string">'#'</span>) {
    <span class="hljs-keyword">this</span>.comment = <span class="hljs-literal">true</span>
    <span class="hljs-keyword">return</span>
  }
  <span class="hljs-keyword">if</span> (!pattern) {
    <span class="hljs-keyword">this</span>.empty = <span class="hljs-literal">true</span>
    <span class="hljs-keyword">return</span>
  }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-15" id="section-15"></a>
</div>
<p>step 1: figure out negation, etc.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-keyword">this</span>.parseNegate()

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-16" id="section-16"></a>
</div>
<p>step 2: expand braces</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-keyword">var</span> set = <span class="hljs-keyword">this</span>.globSet = <span class="hljs-keyword">this</span>.braceExpand()

  <span class="hljs-keyword">if</span> (options.debug) <span class="hljs-keyword">this</span>.debug = <span class="hljs-built_in">console</span>.error

  <span class="hljs-keyword">this</span>.debug(<span class="hljs-keyword">this</span>.pattern, set)

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-17" id="section-17"></a>
</div>
<p>step 3: now we have a set, so turn each one into a series of path-portion
matching patterns.
These will be regexps, except in the case of &quot;**&quot;, which is
set to the GLOBSTAR object for globstar behavior,
and will not contain any / characters</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  set = <span class="hljs-keyword">this</span>.globParts = set.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) </span>{
    <span class="hljs-keyword">return</span> s.split(slashSplit)
  })

  <span class="hljs-keyword">this</span>.debug(<span class="hljs-keyword">this</span>.pattern, set)

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-18" id="section-18"></a>
</div>
<p>glob --&gt; regexps</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  set = set.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s, si, set</span>) </span>{
    <span class="hljs-keyword">return</span> s.map(<span class="hljs-keyword">this</span>.parse, <span class="hljs-keyword">this</span>)
  }, <span class="hljs-keyword">this</span>)

  <span class="hljs-keyword">this</span>.debug(<span class="hljs-keyword">this</span>.pattern, set)

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-19" id="section-19"></a>
</div>
<p>filter out everything that didn't compile properly.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  set = set.filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) </span>{
    <span class="hljs-keyword">return</span> s.indexOf(<span class="hljs-literal">false</span>) === <span class="hljs-number">-1</span>
  })

  <span class="hljs-keyword">this</span>.debug(<span class="hljs-keyword">this</span>.pattern, set)

  <span class="hljs-keyword">this</span>.set = set
}

Minimatch.prototype.parseNegate = parseNegate
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseNegate</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> pattern = <span class="hljs-keyword">this</span>.pattern
  <span class="hljs-keyword">var</span> negate = <span class="hljs-literal">false</span>
  <span class="hljs-keyword">var</span> options = <span class="hljs-keyword">this</span>.options
  <span class="hljs-keyword">var</span> negateOffset = <span class="hljs-number">0</span>

  <span class="hljs-keyword">if</span> (options.nonegate) <span class="hljs-keyword">return</span>

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, l = pattern.length
    ; i &lt; l &amp;&amp; pattern.charAt(i) === <span class="hljs-string">'!'</span>
    ; i++) {
    negate = !negate
    negateOffset++
  }

  <span class="hljs-keyword">if</span> (negateOffset) <span class="hljs-keyword">this</span>.pattern = pattern.substr(negateOffset)
  <span class="hljs-keyword">this</span>.negate = negate
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-20" id="section-20"></a>
</div>
<p>Brace expansion:
a{b,c}d -&gt; abd acd
a{b,}c -&gt; abc ac
a{0..3}d -&gt; a0d a1d a2d a3d
a{b,c{d,e}f}g -&gt; abg acdfg acefg
a{b,c}d{e,f}g -&gt; abdeg acdeg abdeg abdfg</p>
<p>Invalid sets are not expanded.
a{2..}b -&gt; a{2..}b
a{b}c -&gt; a{b}c</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">minimatch.braceExpand = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">pattern, options</span>) </span>{
  <span class="hljs-keyword">return</span> braceExpand(pattern, options)
}

Minimatch.prototype.braceExpand = braceExpand

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">braceExpand</span> (<span class="hljs-params">pattern, options</span>) </span>{
  <span class="hljs-keyword">if</span> (!options) {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> Minimatch) {
      options = <span class="hljs-keyword">this</span>.options
    } <span class="hljs-keyword">else</span> {
      options = {}
    }
  }

  pattern = <span class="hljs-keyword">typeof</span> pattern === <span class="hljs-string">'undefined'</span>
    ? <span class="hljs-keyword">this</span>.pattern : pattern

  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> pattern === <span class="hljs-string">'undefined'</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">'undefined pattern'</span>)
  }

  <span class="hljs-keyword">if</span> (options.nobrace ||
    !pattern.match(<span class="hljs-regexp">/\{.*\}/</span>)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-21" id="section-21"></a>
</div>
<p>shortcut. no need to expand.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">return</span> [pattern]
  }

  <span class="hljs-keyword">return</span> expand(pattern)
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-22" id="section-22"></a>
</div>
<p>parse a component of the expanded set.
At this point, no pattern may contain &quot;/&quot; in it
so we're going to return a 2d array, where each entry is the full
pattern, split on '/', and then turned into a regular expression.
A regexp is made at the end which joins each array with an
escaped /, and another full one which joins each regexp with |.</p>
<p>Following the lead of Bash 4.1, note that &quot;**&quot; only has special meaning
when it is the <em>only</em> thing in a path portion.  Otherwise, any series
of * is equivalent to a single *.  Globstar behavior is enabled by
default, and can be disabled by setting options.noglobstar.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">Minimatch.prototype.parse = parse
<span class="hljs-keyword">var</span> SUBPARSE = {}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parse</span> (<span class="hljs-params">pattern, isSub</span>) </span>{
  <span class="hljs-keyword">if</span> (pattern.length &gt; <span class="hljs-number">1024</span> * <span class="hljs-number">64</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">'pattern is too long'</span>)
  }

  <span class="hljs-keyword">var</span> options = <span class="hljs-keyword">this</span>.options

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-23" id="section-23"></a>
</div>
<p>shortcuts</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-keyword">if</span> (!options.noglobstar &amp;&amp; pattern === <span class="hljs-string">'**'</span>) <span class="hljs-keyword">return</span> GLOBSTAR
  <span class="hljs-keyword">if</span> (pattern === <span class="hljs-string">''</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>

  <span class="hljs-keyword">var</span> re = <span class="hljs-string">''</span>
  <span class="hljs-keyword">var</span> hasMagic = !!options.nocase
  <span class="hljs-keyword">var</span> escaping = <span class="hljs-literal">false</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-24" id="section-24"></a>
</div>
<p>? =&gt; one single character</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-keyword">var</span> patternListStack = []
  <span class="hljs-keyword">var</span> negativeLists = []
  <span class="hljs-keyword">var</span> stateChar
  <span class="hljs-keyword">var</span> inClass = <span class="hljs-literal">false</span>
  <span class="hljs-keyword">var</span> reClassStart = <span class="hljs-number">-1</span>
  <span class="hljs-keyword">var</span> classStart = <span class="hljs-number">-1</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-25" id="section-25"></a>
</div>
<p>. and .. never match anything that doesn't start with .,
even when options.dot is set.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-keyword">var</span> patternStart = pattern.charAt(<span class="hljs-number">0</span>) === <span class="hljs-string">'.'</span> ? <span class="hljs-string">''</span> <span class="hljs-comment">// anything</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-26" id="section-26"></a>
</div>
<p>not (start or / followed by . or .. followed by / or end)</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  : options.dot ? <span class="hljs-string">'(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))'</span>
  : <span class="hljs-string">'(?!\\.)'</span>
  <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clearStateChar</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">if</span> (stateChar) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-27" id="section-27"></a>
</div>
<p>we had some state-tracking character
that wasn't consumed by this pass.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">switch</span> (stateChar) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">'*'</span>:
          re += star
          hasMagic = <span class="hljs-literal">true</span>
        <span class="hljs-keyword">break</span>
        <span class="hljs-keyword">case</span> <span class="hljs-string">'?'</span>:
          re += qmark
          hasMagic = <span class="hljs-literal">true</span>
        <span class="hljs-keyword">break</span>
        <span class="hljs-keyword">default</span>:
          re += <span class="hljs-string">'\\'</span> + stateChar
        <span class="hljs-keyword">break</span>
      }
      self.debug(<span class="hljs-string">'clearStateChar %j %j'</span>, stateChar, re)
      stateChar = <span class="hljs-literal">false</span>
    }
  }

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, len = pattern.length, c
    ; (i &lt; len) &amp;&amp; (c = pattern.charAt(i))
    ; i++) {
    <span class="hljs-keyword">this</span>.debug(<span class="hljs-string">'%s\t%s %s %j'</span>, pattern, i, re, c)

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-28" id="section-28"></a>
</div>
<p>skip over any that are escaped.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">if</span> (escaping &amp;&amp; reSpecials[c]) {
      re += <span class="hljs-string">'\\'</span> + c
      escaping = <span class="hljs-literal">false</span>
      <span class="hljs-keyword">continue</span>
    }

    <span class="hljs-keyword">switch</span> (c) {
      <span class="hljs-keyword">case</span> <span class="hljs-string">'/'</span>:
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-29" id="section-29"></a>
</div>
<p>completely not allowed, even escaped.
Should already be path-split by now.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>

      <span class="hljs-keyword">case</span> <span class="hljs-string">'\\'</span>:
        clearStateChar()
        escaping = <span class="hljs-literal">true</span>
      <span class="hljs-keyword">continue</span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-30" id="section-30"></a>
</div>
<p>the various stateChar values
for the &quot;extglob&quot; stuff.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">case</span> <span class="hljs-string">'?'</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">'*'</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">'+'</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">'@'</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">'!'</span>:
        <span class="hljs-keyword">this</span>.debug(<span class="hljs-string">'%s\t%s %s %j &lt;-- stateChar'</span>, pattern, i, re, c)

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-31" id="section-31"></a>
</div>
<p>all of those are literals inside a class, except that
the glob [!a] means [^a] in regexp</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (inClass) {
          <span class="hljs-keyword">this</span>.debug(<span class="hljs-string">'  in class'</span>)
          <span class="hljs-keyword">if</span> (c === <span class="hljs-string">'!'</span> &amp;&amp; i === classStart + <span class="hljs-number">1</span>) c = <span class="hljs-string">'^'</span>
          re += c
          <span class="hljs-keyword">continue</span>
        }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-32" id="section-32"></a>
</div>
<p>if we already have a stateChar, then it means
that there was something like ** or +? in there.
Handle the stateChar, then proceed with this one.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        self.debug(<span class="hljs-string">'call clearStateChar %j'</span>, stateChar)
        clearStateChar()
        stateChar = c
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-33" id="section-33"></a>
</div>
<p>if extglob is disabled, then +(asdf|foo) isn't a thing.
just clear the statechar <em>now</em>, rather than even diving into
the patternList stuff.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (options.noext) clearStateChar()
      <span class="hljs-keyword">continue</span>

      <span class="hljs-keyword">case</span> <span class="hljs-string">'('</span>:
        <span class="hljs-keyword">if</span> (inClass) {
          re += <span class="hljs-string">'('</span>
          <span class="hljs-keyword">continue</span>
        }

        <span class="hljs-keyword">if</span> (!stateChar) {
          re += <span class="hljs-string">'\\('</span>
          <span class="hljs-keyword">continue</span>
        }

        patternListStack.push({
          <span class="hljs-attr">type</span>: stateChar,
          <span class="hljs-attr">start</span>: i - <span class="hljs-number">1</span>,
          <span class="hljs-attr">reStart</span>: re.length,
          <span class="hljs-attr">open</span>: plTypes[stateChar].open,
          <span class="hljs-attr">close</span>: plTypes[stateChar].close
        })
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-34" id="section-34"></a>
</div>
<p>negation is (?:(?!js)[^/]*)</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        re += stateChar === <span class="hljs-string">'!'</span> ? <span class="hljs-string">'(?:(?!(?:'</span> : <span class="hljs-string">'(?:'</span>
        <span class="hljs-keyword">this</span>.debug(<span class="hljs-string">'plType %j %j'</span>, stateChar, re)
        stateChar = <span class="hljs-literal">false</span>
      <span class="hljs-keyword">continue</span>

      <span class="hljs-keyword">case</span> <span class="hljs-string">')'</span>:
        <span class="hljs-keyword">if</span> (inClass || !patternListStack.length) {
          re += <span class="hljs-string">'\\)'</span>
          <span class="hljs-keyword">continue</span>
        }

        clearStateChar()
        hasMagic = <span class="hljs-literal">true</span>
        <span class="hljs-keyword">var</span> pl = patternListStack.pop()
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-35" id="section-35"></a>
</div>
<p>negation is (?:(?!js)[^/]*)
The others are (?:<pattern>)<type></p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        re += pl.close
        <span class="hljs-keyword">if</span> (pl.type === <span class="hljs-string">'!'</span>) {
          negativeLists.push(pl)
        }
        pl.reEnd = re.length
      <span class="hljs-keyword">continue</span>

      <span class="hljs-keyword">case</span> <span class="hljs-string">'|'</span>:
        <span class="hljs-keyword">if</span> (inClass || !patternListStack.length || escaping) {
          re += <span class="hljs-string">'\\|'</span>
          escaping = <span class="hljs-literal">false</span>
          <span class="hljs-keyword">continue</span>
        }

        clearStateChar()
        re += <span class="hljs-string">'|'</span>
      <span class="hljs-keyword">continue</span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-36" id="section-36"></a>
</div>
<p>these are mostly the same in regexp and glob</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">case</span> <span class="hljs-string">'['</span>:
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-37" id="section-37"></a>
</div>
<p>swallow any state-tracking char before the [</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        clearStateChar()

        <span class="hljs-keyword">if</span> (inClass) {
          re += <span class="hljs-string">'\\'</span> + c
          <span class="hljs-keyword">continue</span>
        }

        inClass = <span class="hljs-literal">true</span>
        classStart = i
        reClassStart = re.length
        re += c
      <span class="hljs-keyword">continue</span>

      <span class="hljs-keyword">case</span> <span class="hljs-string">']'</span>:
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-38" id="section-38"></a>
</div>
<p>a right bracket shall lose its special
meaning and represent itself in
a bracket expression if it occurs
first in the list.  -- POSIX.2 2.8.3.2</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (i === classStart + <span class="hljs-number">1</span> || !inClass) {
          re += <span class="hljs-string">'\\'</span> + c
          escaping = <span class="hljs-literal">false</span>
          <span class="hljs-keyword">continue</span>
        }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-39" id="section-39"></a>
</div>
<p>handle the case where we left a class open.
&quot;[z-a]&quot; is valid, equivalent to &quot;[z-a]&quot;</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (inClass) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-40" id="section-40"></a>
</div>
<p>split where the last [ was, make sure we don't have
an invalid re. if so, re-walk the contents of the
would-be class to re-translate any characters that
were passed through as-is
TODO: It would probably be faster to determine this
without a try/catch and a new RegExp, but it's tricky
to do safely.  For now, this is safe and works.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">var</span> cs = pattern.substring(classStart + <span class="hljs-number">1</span>, i)
          <span class="hljs-keyword">try</span> {
            <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">'['</span> + cs + <span class="hljs-string">']'</span>)
          } <span class="hljs-keyword">catch</span> (er) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-41" id="section-41"></a>
</div>
<p>not a valid class!</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">var</span> sp = <span class="hljs-keyword">this</span>.parse(cs, SUBPARSE)
            re = re.substr(<span class="hljs-number">0</span>, reClassStart) + <span class="hljs-string">'\\['</span> + sp[<span class="hljs-number">0</span>] + <span class="hljs-string">'\\]'</span>
            hasMagic = hasMagic || sp[<span class="hljs-number">1</span>]
            inClass = <span class="hljs-literal">false</span>
            <span class="hljs-keyword">continue</span>
          }
        }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-42" id="section-42"></a>
</div>
<p>finish up the class.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        hasMagic = <span class="hljs-literal">true</span>
        inClass = <span class="hljs-literal">false</span>
        re += c
      <span class="hljs-keyword">continue</span>

      <span class="hljs-keyword">default</span>:
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-43" id="section-43"></a>
</div>
<p>swallow any state char that wasn't consumed</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        clearStateChar()

        <span class="hljs-keyword">if</span> (escaping) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-44" id="section-44"></a>
</div>
<p>no need</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          escaping = <span class="hljs-literal">false</span>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (reSpecials[c]
          &amp;&amp; !(c === <span class="hljs-string">'^'</span> &amp;&amp; inClass)) {
          re += <span class="hljs-string">'\\'</span>
        }

        re += c

    } <span class="hljs-comment">// switch</span>
  } <span class="hljs-comment">// for</span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-45" id="section-45"></a>
</div>
<p>handle the case where we left a class open.
&quot;[abc&quot; is valid, equivalent to &quot;[abc&quot;</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-keyword">if</span> (inClass) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-46" id="section-46"></a>
</div>
<p>split where the last [ was, and escape it
this is a huge pita.  We now have to re-walk
the contents of the would-be class to re-translate
any characters that were passed through as-is</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    cs = pattern.substr(classStart + <span class="hljs-number">1</span>)
    sp = <span class="hljs-keyword">this</span>.parse(cs, SUBPARSE)
    re = re.substr(<span class="hljs-number">0</span>, reClassStart) + <span class="hljs-string">'\\['</span> + sp[<span class="hljs-number">0</span>]
    hasMagic = hasMagic || sp[<span class="hljs-number">1</span>]
  }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-47" id="section-47"></a>
</div>
<p>handle the case where we had a +( thing at the <em>end</em>
of the pattern.
each pattern list stack adds 3 chars, and we need to go through
and escape any | chars that were passed through as-is for the regexp.
Go through and escape them, taking care not to double-escape any
| chars that were already escaped.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-keyword">for</span> (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
    <span class="hljs-keyword">var</span> tail = re.slice(pl.reStart + pl.open.length)
    <span class="hljs-keyword">this</span>.debug(<span class="hljs-string">'setting tail'</span>, re, pl)
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-48" id="section-48"></a>
</div>
<p>maybe some even number of , then maybe 1 , followed by a |</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    tail = tail.replace(<span class="hljs-regexp">/((?:\\{2}){0,64})(\\?)\|/g</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">_, $<span class="hljs-number">1</span>, $<span class="hljs-number">2</span></span>) </span>{
      <span class="hljs-keyword">if</span> (!$<span class="hljs-number">2</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-49" id="section-49"></a>
</div>
<p>the | isn't already escaped, so escape it.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        $<span class="hljs-number">2</span> = <span class="hljs-string">'\\'</span>
      }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-50" id="section-50"></a>
</div>
<p>need to escape all those slashes <em>again</em>, without escaping the
one that we need for escaping the | character.  As it works out,
escaping an even number of slashes can be done by simply repeating
it exactly after itself.  That's why this trick works.</p>
<p>I am sorry that you have to see this.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">return</span> $<span class="hljs-number">1</span> + $<span class="hljs-number">1</span> + $<span class="hljs-number">2</span> + <span class="hljs-string">'|'</span>
    })

    <span class="hljs-keyword">this</span>.debug(<span class="hljs-string">'tail=%j\n   %s'</span>, tail, tail, pl, re)
    <span class="hljs-keyword">var</span> t = pl.type === <span class="hljs-string">'*'</span> ? star
      : pl.type === <span class="hljs-string">'?'</span> ? qmark
      : <span class="hljs-string">'\\'</span> + pl.type

    hasMagic = <span class="hljs-literal">true</span>
    re = re.slice(<span class="hljs-number">0</span>, pl.reStart) + t + <span class="hljs-string">'\\('</span> + tail
  }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-51" id="section-51"></a>
</div>
<p>handle trailing things that only matter at the very end.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  clearStateChar()
  <span class="hljs-keyword">if</span> (escaping) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-52" id="section-52"></a>
</div>
<p>trailing \</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    re += <span class="hljs-string">'\\\\'</span>
  }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-53" id="section-53"></a>
</div>
<p>only need to apply the nodot start if the re starts with
something that could conceivably capture a dot</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-keyword">var</span> addPatternStart = <span class="hljs-literal">false</span>
  <span class="hljs-keyword">switch</span> (re.charAt(<span class="hljs-number">0</span>)) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'.'</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">'['</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">'('</span>: addPatternStart = <span class="hljs-literal">true</span>
  }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-54" id="section-54"></a>
</div>
<p>Hack to work around lack of negative lookbehind in JS
A pattern like: *.!(x).!(y|z) needs to ensure that a name
like 'a.xyz.yz' doesn't match.  So, the first negative
lookahead, has to look ALL the way ahead, to the end of
the pattern.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> n = negativeLists.length - <span class="hljs-number">1</span>; n &gt; <span class="hljs-number">-1</span>; n--) {
    <span class="hljs-keyword">var</span> nl = negativeLists[n]

    <span class="hljs-keyword">var</span> nlBefore = re.slice(<span class="hljs-number">0</span>, nl.reStart)
    <span class="hljs-keyword">var</span> nlFirst = re.slice(nl.reStart, nl.reEnd - <span class="hljs-number">8</span>)
    <span class="hljs-keyword">var</span> nlLast = re.slice(nl.reEnd - <span class="hljs-number">8</span>, nl.reEnd)
    <span class="hljs-keyword">var</span> nlAfter = re.slice(nl.reEnd)

    nlLast += nlAfter

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-55" id="section-55"></a>
</div>
<p>Handle nested stuff like <em>(</em>.js|!(*.json)), where open parens
mean that we should <em>not</em> include the ) in the bit that is considered
&quot;after&quot; the negated section.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">var</span> openParensBefore = nlBefore.split(<span class="hljs-string">'('</span>).length - <span class="hljs-number">1</span>
    <span class="hljs-keyword">var</span> cleanAfter = nlAfter
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; openParensBefore; i++) {
      cleanAfter = cleanAfter.replace(<span class="hljs-regexp">/\)[+*?]?/</span>, <span class="hljs-string">''</span>)
    }
    nlAfter = cleanAfter

    <span class="hljs-keyword">var</span> dollar = <span class="hljs-string">''</span>
    <span class="hljs-keyword">if</span> (nlAfter === <span class="hljs-string">''</span> &amp;&amp; isSub !== SUBPARSE) {
      dollar = <span class="hljs-string">'$'</span>
    }
    <span class="hljs-keyword">var</span> newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast
    re = newRe
  }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-56" id="section-56"></a>
</div>
<p>if the re is not &quot;&quot; at this point, then we need to make sure
it doesn't match against an empty path part.
Otherwise a/* will match a/, which it should not.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-keyword">if</span> (re !== <span class="hljs-string">''</span> &amp;&amp; hasMagic) {
    re = <span class="hljs-string">'(?=.)'</span> + re
  }

  <span class="hljs-keyword">if</span> (addPatternStart) {
    re = patternStart + re
  }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-57" id="section-57"></a>
</div>
<p>parsing just a piece of a larger pattern.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-keyword">if</span> (isSub === SUBPARSE) {
    <span class="hljs-keyword">return</span> [re, hasMagic]
  }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-58" id="section-58"></a>
</div>
<p>skip the regexp for non-magical patterns
unescape anything in it, though, so that it'll be
an exact match against a file etc.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-keyword">if</span> (!hasMagic) {
    <span class="hljs-keyword">return</span> globUnescape(pattern)
  }

  <span class="hljs-keyword">var</span> flags = options.nocase ? <span class="hljs-string">'i'</span> : <span class="hljs-string">''</span>
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">var</span> regExp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">'^'</span> + re + <span class="hljs-string">'$'</span>, flags)
  } <span class="hljs-keyword">catch</span> (er) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-59" id="section-59"></a>
</div>
<p>If it was an invalid regular expression, then it can't match
anything.  This trick looks for a character after the end of
the string, which is of course impossible, except in multi-line
mode, but it's not a /m regex.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">'$.'</span>)
  }

  regExp._glob = pattern
  regExp._src = re

  <span class="hljs-keyword">return</span> regExp
}

minimatch.makeRe = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">pattern, options</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Minimatch(pattern, options || {}).makeRe()
}

Minimatch.prototype.makeRe = makeRe
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeRe</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.regexp || <span class="hljs-keyword">this</span>.regexp === <span class="hljs-literal">false</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.regexp

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-60" id="section-60"></a>
</div>
<p>at this point, this.set is a 2d array of partial
pattern strings, or &quot;**&quot;.</p>
<p>It's better to use .match().  This function shouldn't
be used, really, but it's pretty convenient sometimes,
when you just want to work with a regex.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-keyword">var</span> set = <span class="hljs-keyword">this</span>.set

  <span class="hljs-keyword">if</span> (!set.length) {
    <span class="hljs-keyword">this</span>.regexp = <span class="hljs-literal">false</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.regexp
  }
  <span class="hljs-keyword">var</span> options = <span class="hljs-keyword">this</span>.options

  <span class="hljs-keyword">var</span> twoStar = options.noglobstar ? star
    : options.dot ? twoStarDot
    : twoStarNoDot
  <span class="hljs-keyword">var</span> flags = options.nocase ? <span class="hljs-string">'i'</span> : <span class="hljs-string">''</span>

  <span class="hljs-keyword">var</span> re = set.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">pattern</span>) </span>{
    <span class="hljs-keyword">return</span> pattern.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">p</span>) </span>{
      <span class="hljs-keyword">return</span> (p === GLOBSTAR) ? twoStar
      : (<span class="hljs-keyword">typeof</span> p === <span class="hljs-string">'string'</span>) ? regExpEscape(p)
      : p._src
    }).join(<span class="hljs-string">'\\\/'</span>)
  }).join(<span class="hljs-string">'|'</span>)

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-61" id="section-61"></a>
</div>
<p>must match entire pattern
ending in a * or ** will make it less strict.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  re = <span class="hljs-string">'^(?:'</span> + re + <span class="hljs-string">')$'</span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-62" id="section-62"></a>
</div>
<p>can match anything, as long as it's not this.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.negate) re = <span class="hljs-string">'^(?!'</span> + re + <span class="hljs-string">').*$'</span>

  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">this</span>.regexp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(re, flags)
  } <span class="hljs-keyword">catch</span> (ex) {
    <span class="hljs-keyword">this</span>.regexp = <span class="hljs-literal">false</span>
  }
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.regexp
}

minimatch.match = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">list, pattern, options</span>) </span>{
  options = options || {}
  <span class="hljs-keyword">var</span> mm = <span class="hljs-keyword">new</span> Minimatch(pattern, options)
  list = list.filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">f</span>) </span>{
    <span class="hljs-keyword">return</span> mm.match(f)
  })
  <span class="hljs-keyword">if</span> (mm.options.nonull &amp;&amp; !list.length) {
    list.push(pattern)
  }
  <span class="hljs-keyword">return</span> list
}

Minimatch.prototype.match = match
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">match</span> (<span class="hljs-params">f, partial</span>) </span>{
  <span class="hljs-keyword">this</span>.debug(<span class="hljs-string">'match'</span>, f, <span class="hljs-keyword">this</span>.pattern)
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-63" id="section-63"></a>
</div>
<p>short-circuit in the case of busted things.
comments, etc.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.comment) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.empty) <span class="hljs-keyword">return</span> f === <span class="hljs-string">''</span>

  <span class="hljs-keyword">if</span> (f === <span class="hljs-string">'/'</span> &amp;&amp; partial) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>

  <span class="hljs-keyword">var</span> options = <span class="hljs-keyword">this</span>.options

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-64" id="section-64"></a>
</div>
<p>windows: need to use /, not \</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-keyword">if</span> (path.sep !== <span class="hljs-string">'/'</span>) {
    f = f.split(path.sep).join(<span class="hljs-string">'/'</span>)
  }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-65" id="section-65"></a>
</div>
<p>treat the test path as a set of pathparts.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  f = f.split(slashSplit)
  <span class="hljs-keyword">this</span>.debug(<span class="hljs-keyword">this</span>.pattern, <span class="hljs-string">'split'</span>, f)

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-66" id="section-66"></a>
</div>
<p>just ONE of the pattern sets in this.set needs to match
in order for it to be valid.  If negating, then just one
match means that we have failed.
Either way, return on the first hit.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
  <span class="hljs-keyword">var</span> set = <span class="hljs-keyword">this</span>.set
  <span class="hljs-keyword">this</span>.debug(<span class="hljs-keyword">this</span>.pattern, <span class="hljs-string">'set'</span>, set)

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-67" id="section-67"></a>
</div>
<p>Find the basename of the path by looking for the last non-empty segment</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-keyword">var</span> filename
  <span class="hljs-keyword">var</span> i
  <span class="hljs-keyword">for</span> (i = f.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {
    filename = f[i]
    <span class="hljs-keyword">if</span> (filename) <span class="hljs-keyword">break</span>
  }

  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; set.length; i++) {
    <span class="hljs-keyword">var</span> pattern = set[i]
    <span class="hljs-keyword">var</span> file = f
    <span class="hljs-keyword">if</span> (options.matchBase &amp;&amp; pattern.length === <span class="hljs-number">1</span>) {
      file = [filename]
    }
    <span class="hljs-keyword">var</span> hit = <span class="hljs-keyword">this</span>.matchOne(file, pattern, partial)
    <span class="hljs-keyword">if</span> (hit) {
      <span class="hljs-keyword">if</span> (options.flipNegate) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
      <span class="hljs-keyword">return</span> !<span class="hljs-keyword">this</span>.negate
    }
  }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-68" id="section-68"></a>
</div>
<p>didn't get any hits.  this is success if it's a negative
pattern, failure otherwise.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-keyword">if</span> (options.flipNegate) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.negate
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-69" id="section-69"></a>
</div>
<p>set partial to true to test if, for example,
&quot;/a/b&quot; matches the start of &quot;/<em>/b/</em>/d&quot;
Partial means, if you run out of file before you run
out of pattern, then that's fine, as long as all
the parts match.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">Minimatch.prototype.matchOne = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">file, pattern, partial</span>) </span>{
  <span class="hljs-keyword">var</span> options = <span class="hljs-keyword">this</span>.options

  <span class="hljs-keyword">this</span>.debug(<span class="hljs-string">'matchOne'</span>,
    { <span class="hljs-string">'this'</span>: <span class="hljs-keyword">this</span>, <span class="hljs-attr">file</span>: file, <span class="hljs-attr">pattern</span>: pattern })

  <span class="hljs-keyword">this</span>.debug(<span class="hljs-string">'matchOne'</span>, file.length, pattern.length)

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> fi = <span class="hljs-number">0</span>,
      pi = <span class="hljs-number">0</span>,
      fl = file.length,
      pl = pattern.length
      ; (fi &lt; fl) &amp;&amp; (pi &lt; pl)
      ; fi++, pi++) {
    <span class="hljs-keyword">this</span>.debug(<span class="hljs-string">'matchOne loop'</span>)
    <span class="hljs-keyword">var</span> p = pattern[pi]
    <span class="hljs-keyword">var</span> f = file[fi]

    <span class="hljs-keyword">this</span>.debug(pattern, p, f)

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-70" id="section-70"></a>
</div>
<p>should be impossible.
some invalid regexp stuff in the set.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">if</span> (p === <span class="hljs-literal">false</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>

    <span class="hljs-keyword">if</span> (p === GLOBSTAR) {
      <span class="hljs-keyword">this</span>.debug(<span class="hljs-string">'GLOBSTAR'</span>, [pattern, p, f])

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-71" id="section-71"></a>
</div>
<p>&quot;<strong>&quot;
a/</strong>/b/**/c would match the following:
a/b/x/y/z/c
a/x/y/z/b/c
a/b/x/b/x/c
a/b/c
To do this, take the rest of the pattern after
the **, and see if it would match the file remainder.
If so, return success.
If not, the ** &quot;swallows&quot; a segment, and try again.
This is recursively awful.</p>
<p>a/<strong>/b/</strong>/c matching a/b/x/y/z/c</p>
<ul>
<li>a matches a</li>
<li>doublestar
<ul>
<li>matchOne(b/x/y/z/c, b/**/c)
<ul>
<li>b matches b</li>
<li>doublestar
<ul>
<li>matchOne(x/y/z/c, c) -&gt; no</li>
<li>matchOne(y/z/c, c) -&gt; no</li>
<li>matchOne(z/c, c) -&gt; no</li>
<li>matchOne(c, c) yes, hit</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">var</span> fr = fi
      <span class="hljs-keyword">var</span> pr = pi + <span class="hljs-number">1</span>
      <span class="hljs-keyword">if</span> (pr === pl) {
        <span class="hljs-keyword">this</span>.debug(<span class="hljs-string">'** at the end'</span>)
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-72" id="section-72"></a>
</div>
<p>a ** at the end will just swallow the rest.
We have found a match.
however, it will not swallow /.x, unless
options.dot is set.
. and .. are <em>never</em> matched by **, for explosively
exponential reasons.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">for</span> (; fi &lt; fl; fi++) {
          <span class="hljs-keyword">if</span> (file[fi] === <span class="hljs-string">'.'</span> || file[fi] === <span class="hljs-string">'..'</span> ||
            (!options.dot &amp;&amp; file[fi].charAt(<span class="hljs-number">0</span>) === <span class="hljs-string">'.'</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
      }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-73" id="section-73"></a>
</div>
<p>ok, let's see if we can swallow whatever we can.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">while</span> (fr &lt; fl) {
        <span class="hljs-keyword">var</span> swallowee = file[fr]

        <span class="hljs-keyword">this</span>.debug(<span class="hljs-string">'\nglobstar while'</span>, file, fr, pattern, pr, swallowee)

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-74" id="section-74"></a>
</div>
<p>XXX remove this slice.  Just pass the start index.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
          <span class="hljs-keyword">this</span>.debug(<span class="hljs-string">'globstar found match!'</span>, fr, fl, swallowee)
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-75" id="section-75"></a>
</div>
<p>found a match.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
        } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-76" id="section-76"></a>
</div>
<p>can't swallow &quot;.&quot; or &quot;..&quot; ever.
can only swallow &quot;.foo&quot; when explicitly asked.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">if</span> (swallowee === <span class="hljs-string">'.'</span> || swallowee === <span class="hljs-string">'..'</span> ||
            (!options.dot &amp;&amp; swallowee.charAt(<span class="hljs-number">0</span>) === <span class="hljs-string">'.'</span>)) {
            <span class="hljs-keyword">this</span>.debug(<span class="hljs-string">'dot detected!'</span>, file, fr, pattern, pr)
            <span class="hljs-keyword">break</span>
          }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-77" id="section-77"></a>
</div>
<p>** swallows a segment, and continue.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">this</span>.debug(<span class="hljs-string">'globstar swallow a segment, and continue'</span>)
          fr++
        }
      }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-78" id="section-78"></a>
</div>
<p>no match was found.
However, in partial mode, we can't say this is necessarily over.
If there's more <em>pattern</em> left, then</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">if</span> (partial) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-79" id="section-79"></a>
</div>
<p>ran out of file</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">this</span>.debug(<span class="hljs-string">'\n&gt;&gt;&gt; no match, partial?'</span>, file, fr, pattern, pr)
        <span class="hljs-keyword">if</span> (fr === fl) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
      }
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-80" id="section-80"></a>
</div>
<p>something other than **
non-magic patterns just have to match exactly
patterns with magic have been turned into regexps.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">var</span> hit
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> p === <span class="hljs-string">'string'</span>) {
      <span class="hljs-keyword">if</span> (options.nocase) {
        hit = f.toLowerCase() === p.toLowerCase()
      } <span class="hljs-keyword">else</span> {
        hit = f === p
      }
      <span class="hljs-keyword">this</span>.debug(<span class="hljs-string">'string match'</span>, p, f, hit)
    } <span class="hljs-keyword">else</span> {
      hit = f.match(p)
      <span class="hljs-keyword">this</span>.debug(<span class="hljs-string">'pattern match'</span>, p, f, hit)
    }

    <span class="hljs-keyword">if</span> (!hit) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
  }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-81" id="section-81"></a>
</div>
<p>Note: ending in / means that we'll get a final &quot;&quot;
at the end of the pattern.  This can only match a
corresponding &quot;&quot; at the end of the file.
If the file ends in /, then it can only match a
a pattern that ends in /, unless the pattern just
doesn't have any more for it. But, a/b/ should <em>not</em>
match &quot;a/b/<em>&quot;, even though &quot;&quot; matches against the
[^/]</em>? pattern, except in partial mode, where it might
simply not be reached yet.
However, a/b/ should still satisfy a/*</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-82" id="section-82"></a>
</div>
<p>now either we fell off the end of the pattern, or we're done.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-keyword">if</span> (fi === fl &amp;&amp; pi === pl) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-83" id="section-83"></a>
</div>
<p>ran out of pattern and filename at the same time.
an exact hit!</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (fi === fl) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-84" id="section-84"></a>
</div>
<p>ran out of file, but still had pattern left.
this is ok if we're doing the match as part of
a glob fs traversal.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">return</span> partial
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pi === pl) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-85" id="section-85"></a>
</div>
<p>ran out of pattern, still have file left.
this is only acceptable if we're on the very last
empty segment of a file with a trailing slash.
a/* should match a/b/</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">var</span> emptyFileEnd = (fi === fl - <span class="hljs-number">1</span>) &amp;&amp; (file[fi] === <span class="hljs-string">''</span>)
    <span class="hljs-keyword">return</span> emptyFileEnd
  }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-86" id="section-86"></a>
</div>
<p>should be unreachable.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'wtf?'</span>)
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-87" id="section-87"></a>
</div>
<p>replace stuff like * with *</p>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">globUnescape</span> (<span class="hljs-params">s</span>) </span>{
  <span class="hljs-keyword">return</span> s.replace(<span class="hljs-regexp">/\\(.)/g</span>, <span class="hljs-string">'$1'</span>)
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">regExpEscape</span> (<span class="hljs-params">s</span>) </span>{
  <span class="hljs-keyword">return</span> s.replace(<span class="hljs-regexp">/[-[\]{}()*+?.,\\^$|#\s]/g</span>, <span class="hljs-string">'\\$&amp;'</span>)
}

</pre>
        </td>
      </tr>
    
  </tbody>
</table>

  </div>
</body>
</html>
