<!DOCTYPE html>
<html>
<head>
  <title>README.md</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="../../doc-style.css" />
  <script src="../../doc-filelist.js"></script>
  <script>
    var relativeDir = "../../";
    var thisFile = "node_modules\\graphql-middleware\\README.md";
    var defaultSidebar = true;
  </script>
  <script src="../../doc-script.js"></script>

</head>
<body>
  <div id="sidebar_wrapper">
    <div id="sidebar_switch">
      <span class="tree">Files</span>
      <span class="headings">Headings</span>
    </div>
    <div id="tree"></div>
    <div id="headings">

      <div class="heading h1">
        <a href="#graphql-middleware">graphql-middleware</a>
      </div>

      <div class="heading h2">
        <a href="#overview">Overview</a>
      </div>

      <div class="heading h2">
        <a href="#install">Install</a>
      </div>

      <div class="heading h2">
        <a href="#how-does-it-work">How does it work</a>
      </div>

      <div class="heading h2">
        <a href="#standalone-usage">Standalone usage</a>
      </div>

      <div class="heading h3">
        <a href="#usage-with-graphql-yoga">Usage with graphql-yoga</a>
      </div>

      <div class="heading h2">
        <a href="#awesome-plugins">Awesome Plugins </a>
      </div>

      <div class="heading h2">
        <a href="#api">API</a>
      </div>

      <div class="heading h3">
        <a href="#middleware-generator">Middleware Generator</a>
      </div>

      <div class="heading h3">
        <a href="#middleware-fragments">Middleware Fragments</a>
      </div>

      <div class="heading h2">
        <a href="#graphql-middleware-use-cases">GraphQL Middleware Use Cases</a>
      </div>

      <div class="heading h2">
        <a href="#faq">FAQ</a>
      </div>

      <div class="heading h3">
        <a href="#can-i-use-graphql-middleware-without-graphql-yoga">Can I use GraphQL Middleware without GraphQL Yoga?</a>
      </div>

      <div class="heading h3">
        <a href="#how-does-graphql-middleware-compare-to-directives">How does GraphQL Middleware compare to directives?</a>
      </div>

      <div class="heading h3">
        <a href="#should-i-modify-the-context-using-graphql-middleware">Should I modify the context using GraphQL Middleware?</a>
      </div>

      <div class="heading h2">
        <a href="#help-and-community">Help &amp;amp; Community </a>
      </div>

    </div>
  </div>
  <div id="sidebar-toggle"></div>
  <div id="container">
    <div class="docs markdown"><p align="center"><img src="media/logo.png" width="150" /></p>
<div class="pilwrap" id="graphql-middleware">
  <h1>
    <a href="#graphql-middleware" name="graphql-middleware" class="pilcrow"></a>
graphql-middleware
  </h1>
</div>
<p><a href="https://circleci.com/gh/prismagraphql/graphql-middleware"><img src="https://circleci.com/gh/prismagraphql/graphql-middleware.svg?style=shield" alt="CircleCI"></a>
<a href="https://badge.fury.io/js/graphql-middleware"><img src="https://badge.fury.io/js/graphql-middleware.svg" alt="npm version"></a></p>
<p>All in one solution to manage middleware in your GraphQL projects.</p>
<div class="pilwrap" id="overview">
  <h2>
    <a href="#overview" name="overview" class="pilcrow"></a>
Overview
  </h2>
</div>
<p>GraphQL Middleware is a schema wrapper which allows you to manage additional functionality across multiple resolvers efficiently.</p>
<ul>
<li><strong>Easiest way to handle GraphQL middleware:</strong> An intuitive, yet familiar API that you will pick up in a second.</li>
<li><strong>Powerful:</strong> Allows complete control over your resolvers (Before, After).</li>
<li><strong>Compatible:</strong> Works with any GraphQL Schema.</li>
<li><strong>Remote:</strong> Accepts <code>fragments</code> in resolvers to connect with remote schemas.</li>
</ul>
<div class="pilwrap" id="install">
  <h2>
    <a href="#install" name="install" class="pilcrow"></a>
Install
  </h2>
</div>
<pre><code class="sh">yarn add graphql-middleware
</code></pre>
<div class="pilwrap" id="how-does-it-work">
  <h2>
    <a href="#how-does-it-work" name="how-does-it-work" class="pilcrow"></a>
How does it work
  </h2>
</div>
<p>GraphQL Middleware lets you run arbitrary code before or after a resolver is invoked. It improves your code structure by enabling code reuse and a clear separation of concerns.</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> { GraphQLServer } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'graphql-yoga'</span>)

<span class="hljs-keyword">const</span> typeDefs = <span class="hljs-string">`
type Query {
  hello(name: String): String
  bye(name: String): String
}
`</span>
<span class="hljs-keyword">const</span> resolvers = {
  Query: {
    hello: <span class="hljs-function">(<span class="hljs-params">root, args, context, info</span>) =&gt;</span> {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`3. resolver: hello`</span>)
      <span class="hljs-keyword">return</span> <span class="hljs-string">`Hello <span class="hljs-subst">${args.name ? args.name : 'world'}</span>!`</span>
    },
    bye: <span class="hljs-function">(<span class="hljs-params">root, args, context, info</span>) =&gt;</span> {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`3. resolver: bye`</span>)
      <span class="hljs-keyword">return</span> <span class="hljs-string">`Bye <span class="hljs-subst">${args.name ? args.name : 'world'}</span>!`</span>
    },
  },
}

<span class="hljs-keyword">const</span> logInput = <span class="hljs-keyword">async</span> (resolve, root, args, context, info) =&gt; {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`1. logInput: <span class="hljs-subst">${JSON.stringify(args)}</span>`</span>)
  <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> resolve(root, args, context, info)
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`5. logInput`</span>)
  <span class="hljs-keyword">return</span> result
}

<span class="hljs-keyword">const</span> logResult = <span class="hljs-keyword">async</span> (resolve, root, args, context, info) =&gt; {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`2. logResult`</span>)
  <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> resolve(root, args, context, info)
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`4. logResult: <span class="hljs-subst">${JSON.stringify(result)}</span>`</span>)
  <span class="hljs-keyword">return</span> result
}

<span class="hljs-keyword">const</span> server = <span class="hljs-keyword">new</span> GraphQLServer({
  typeDefs,
  resolvers,
  middlewares: [logInput, logResult],
})
server.start(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Server is running on http://localhost:4000'</span>))
</code></pre>
<p>Execution of the middleware and resolver functions follow the &quot;onion&quot;-principle, meaning each middleware function adds a layer before and after the actual resolver invocation.</p>
<p align="center"><img src="media/idea.png" /></p>
<blockquote>
<p>The order of the middleware functions in the middlewares array is important. The first resolver is the &quot;most-outer&quot; layer, so it gets executed first and last. The second resolver is the &quot;second-outer&quot; layer, so it gets executed second and second to last... And so forth.</p>
</blockquote>
<blockquote>
<p>You can read more about GraphQL Middleware in this fantastic <a href="https://www.prisma.io/blog/graphql-middleware-zie3iphithxy/">article</a>.</p>
</blockquote>
<div class="pilwrap" id="standalone-usage">
  <h2>
    <a href="#standalone-usage" name="standalone-usage" class="pilcrow"></a>
Standalone usage
  </h2>
</div>
<pre><code class="ts"><span class="hljs-keyword">import</span> { applyMiddleware } <span class="hljs-keyword">from</span> <span class="hljs-string">'graphql-middleware'</span>
<span class="hljs-keyword">import</span> { makeExecutableSchema } <span class="hljs-keyword">from</span> <span class="hljs-string">'graphql-tools'</span>
<span class="hljs-keyword">import</span> { authMiddleware, metricsMiddleware } <span class="hljs-keyword">from</span> <span class="hljs-string">'./middleware'</span>

<span class="hljs-comment">// Minimal example middleware (before &amp; after)</span>
<span class="hljs-keyword">const</span> beepMiddleware = {
  Query: {
    hello: <span class="hljs-keyword">async</span> (resolve, parent, args, context, info) =&gt; {
      <span class="hljs-comment">// You can you middleware to override arguments</span>
      <span class="hljs-keyword">const</span> argsWithDefault = { name: <span class="hljs-string">'Bob'</span>, ...args }
      <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> resolve(parent, argsWithDefault, context, info)
      <span class="hljs-comment">// Or change the returned values of resolvers</span>
      <span class="hljs-keyword">return</span> result.replace(<span class="hljs-regexp">/Trump/g</span>, <span class="hljs-string">'beep'</span>)
    },
  },
}

<span class="hljs-keyword">const</span> typeDefs = <span class="hljs-string">`
  type Query {
    hello(name: String): String
  }
`</span>
<span class="hljs-keyword">const</span> resolvers = {
  Query: {
    hello: <span class="hljs-function">(<span class="hljs-params">parent, { name }, context</span>) =&gt;</span> <span class="hljs-string">`Hello <span class="hljs-subst">${name ? name : 'world'}</span>!`</span>,
  },
}

<span class="hljs-keyword">const</span> schema = makeExecutableSchema({ typeDefs, resolvers })

<span class="hljs-keyword">const</span> schemaWithMiddleware = applyMiddleware(
  schema,
  metricsMiddleware,
  authMiddleware,
  beepMiddleware,
)
</code></pre>
<div class="pilwrap" id="usage-with-graphql-yoga">
  <h3>
    <a href="#usage-with-graphql-yoga" name="usage-with-graphql-yoga" class="pilcrow"></a>
Usage with <code>graphql-yoga</code>
  </h3>
</div>
<blockquote>
<p><code>graphql-yoga</code> has built-in support for <code>graphql-middleware</code>!</p>
</blockquote>
<pre><code class="ts"><span class="hljs-keyword">import</span> { GraphQLServer } <span class="hljs-keyword">from</span> <span class="hljs-string">'graphql-yoga'</span>
<span class="hljs-keyword">import</span> { authMiddleware, metricsMiddleware } <span class="hljs-keyword">from</span> <span class="hljs-string">'./middleware'</span>

<span class="hljs-keyword">const</span> typeDefs = <span class="hljs-string">`
  type Query {
    hello(name: String): String
  }
`</span>
<span class="hljs-keyword">const</span> resolvers = {
  Query: {
    hello: <span class="hljs-function">(<span class="hljs-params">parent, { name }, context</span>) =&gt;</span> <span class="hljs-string">`Hello <span class="hljs-subst">${name ? name : 'world'}</span>!`</span>,
  },
}

<span class="hljs-keyword">const</span> server = <span class="hljs-keyword">new</span> GraphQLServer({
  typeDefs,
  resolvers,
  middlewares: [authMiddleware, metricsMiddleware],
  documentMiddleware: [],
})
server.start(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Server is running on localhost:4000'</span>))
</code></pre>
<div class="pilwrap" id="awesome-plugins">
  <h2>
    <a href="#awesome-plugins" name="awesome-plugins" class="pilcrow"></a>
Awesome Plugins <a href="https://awesome.re"><img src="https://awesome.re/badge.svg" alt="Awesome"></a>
  </h2>
</div>
<ul>
<li><a href="http://github.com/homeroom-live/graphql-middleware-apollo-upload-server">graphql-middleware-apollo-upload-server</a> - Uploading files is hard, that's why this package manages it for you!</li>
<li><a href="https://github.com/maticzav/graphql-shield">graphql-shield</a> - Permissions as another layer of abstraction.</li>
<li><a href="https://github.com/maticzav/graphql-middleware-sentry">graphql-middleware-sentry</a> - Report your server errors to Sentry.</li>
<li><a href="https://github.com/maticzav/graphql-middleware-forward-binding">graphql-middleware-forward-binding</a> - GraphQL Binding forwardTo plugin for GraphQL Middleware.</li>
</ul>
<div class="pilwrap" id="api">
  <h2>
    <a href="#api" name="api" class="pilcrow"></a>
API
  </h2>
</div>
<p>A middleware is a resolver function that wraps another resolver function.</p>
<pre><code class="ts">export declare type IMiddlewareResolver&lt;
  TSource = any,
  TContext = any,
  TArgs = any
&gt; = (
  resolve: Function,
  parent: TSource,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo,
) =&gt; Promise&lt;any&gt;

export interface IMiddlewareWithOptions&lt;
  TSource = any,
  TContext = any,
  TArgs = any
&gt; {
  fragment?: IMiddlewareFragment
  fragments?: IMiddlewareFragment[]
  resolve?: IMiddlewareResolver&lt;TSource, TContext, TArgs&gt;
}

export type IMiddlewareFunction&lt;TSource = any, TContext = any, TArgs = any&gt; =
  | IMiddlewareWithOptions&lt;TSource, TContext, TArgs&gt;
  | IMiddlewareResolver&lt;TSource, TContext, TArgs&gt;

interface IMiddlewareTypeMap {
  [key: string]: IMiddlewareFunction | IMiddlewareFieldMap
}

interface IMiddlewareFieldMap {
  [key: string]: IMiddlewareFunction
}

type IMiddleware = IMiddlewareFunction | IMiddlewareTypeMap

function middleware(
  generator: (schema: GraphQLSchema) =&gt; IMiddleware,
): MiddlewareGenerator

function applyMiddleware(
  schema: GraphQLSchema,
  ...middleware: (IMiddleware | MiddlewareGenerator)[]
): GraphQLSchema &amp; {
  schema?: GraphQLSchema
  fragmentReplacements?: FragmentReplacement[]
}

/**
 * Applies middleware to a schema like `applyMiddleware` but only applies the
 * middleware to fields that have non-default resolvers. This method can be
 * useful if you want to report performance of only non-trivial methods.
 */
function applyMiddlewareToDeclaredResolvers(
  schema: GraphQLSchema,
  ...middleware: (IMiddleware | MiddlewareGenerator)[]
): GraphQLSchema &amp; {
  schema?: GraphQLSchema
  fragmentReplacements?: FragmentReplacement[]
}
</code></pre>
<div class="pilwrap" id="middleware-generator">
  <h3>
    <a href="#middleware-generator" name="middleware-generator" class="pilcrow"></a>
Middleware Generator
  </h3>
</div>
<p>In some cases, your middleware could depend on how your schema looks. In such situations, you can turn your middleware into a middleware generator. Middleware generators are denoted with function <code>middleware</code> and receive <code>schema</code> as the first argument.</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> schemaDependentMiddleware = middleware(<span class="hljs-function"><span class="hljs-params">schema</span> =&gt;</span> {
  <span class="hljs-keyword">return</span> generateMiddlewareFromSchema(schema)
})

<span class="hljs-keyword">const</span> schemaWithMiddleware = applyMiddleware(
  schema,
  schemaDependentMiddleware,
  someOtherOptionalMiddleware,
  etc,
)
</code></pre>
<div class="pilwrap" id="middleware-fragments">
  <h3>
    <a href="#middleware-fragments" name="middleware-fragments" class="pilcrow"></a>
Middleware Fragments
  </h3>
</div>
<p>Fragments are a way of expressing what information your resolver requires to make sure it can execute correctly. They are primarily used in schema forwarding when the client might not always request all the fields your resolver demands. Because of that, we need to provide a way of telling what other information we need from a remote schema and that's why we use fragments.</p>
<p>You can read more about fragments in the <a href="https://github.com/graphql-binding/graphql-binding"><code>graphql-binding</code></a> repository and on <a href="https://www.apollographql.com/docs/graphql-tools/schema-transforms.html#Other"><code>graphql-tools</code></a> documentation website.</p>
<p>GraphQL Middleware provides a convenient way to quickly and easily add fragments to your middleware. This might turn out particularly useful when your middleware depends on resolver data.</p>
<p>We've made fragments extremely flexible by using the general API which, if you have ever run over fragments, you probably already know.</p>
<pre><code class="ts"><span class="hljs-comment">// Schema wide - gets applied to every field.</span>
<span class="hljs-keyword">const</span> middlewareWithFragments = {
  fragment: <span class="hljs-string">`fragment NodeID on Node { id }`</span>,
  resolve: <span class="hljs-function">(<span class="hljs-params">resolve, { id }, args, ctx, info</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> foo = doSomethingWithID(id)
    <span class="hljs-keyword">return</span> resolve(foo)
  },
}

<span class="hljs-comment">// Type wide - gets applied to every field of certain type.</span>
<span class="hljs-keyword">const</span> middlewareWithFragments = {
  Query: {
    fragment: <span class="hljs-string">`fragment NodeID on Node { id }`</span>,
    resolve: <span class="hljs-function">(<span class="hljs-params">resolve, { id }, args, ctx, info</span>) =&gt;</span> {
      <span class="hljs-keyword">const</span> foo = doSomethingWithID(id)
      <span class="hljs-keyword">return</span> resolve(foo)
    },
  },
  Mutation: {
    fragments: [
      <span class="hljs-string">`fragment NodeID on Node { id }`</span>,
      <span class="hljs-string">`fragment NodeSecret on Node { secret }`</span>,
    ],
    resolve: <span class="hljs-function">(<span class="hljs-params">resolve, parent, args, ctx, info</span>) =&gt;</span> {
      <span class="hljs-keyword">return</span> resolve(parent, customArgs)
    },
  },
}

<span class="hljs-comment">// Field scoped - gets applied to particular field.</span>
<span class="hljs-keyword">const</span> middlewareWithFragments = {
  Query: {
    node: {
      fragment: <span class="hljs-string">`fragment NodeID on Node { id }`</span>,
      resolve: <span class="hljs-function">(<span class="hljs-params">resolve, { id }, args, ctx, info</span>) =&gt;</span> {
        <span class="hljs-keyword">const</span> foo = doSomethingWithID(id)
        <span class="hljs-keyword">return</span> resolve(foo)
      },
    },
    books: <span class="hljs-function">(<span class="hljs-params">resolve, parent, args, ctx, info</span>) =&gt;</span> {
      <span class="hljs-keyword">return</span> resolve(parent, customArgs)
    },
  },
}

<span class="hljs-keyword">const</span> { schema, fragmentReplacements } = applyMiddleware(
  schema,
  middlewareWithFragments,
  someOtherMiddleware,
)
</code></pre>
<blockquote>
<p><code>graphql-middleware</code> automatically merges fragments from multiple middlewares if possible. Otherwise, validation function throws an error.</p>
</blockquote>
<div class="pilwrap" id="graphql-middleware-use-cases">
  <h2>
    <a href="#graphql-middleware-use-cases" name="graphql-middleware-use-cases" class="pilcrow"></a>
GraphQL Middleware Use Cases
  </h2>
</div>
<ul>
<li>Logging</li>
<li>Metrics</li>
<li>Input sanitisation</li>
<li>Performance measurement</li>
<li>Authorization</li>
<li>Caching</li>
<li>Tracing</li>
</ul>
<div class="pilwrap" id="faq">
  <h2>
    <a href="#faq" name="faq" class="pilcrow"></a>
FAQ
  </h2>
</div>
<div class="pilwrap" id="can-i-use-graphql-middleware-without-graphql-yoga">
  <h3>
    <a href="#can-i-use-graphql-middleware-without-graphql-yoga" name="can-i-use-graphql-middleware-without-graphql-yoga" class="pilcrow"></a>
Can I use GraphQL Middleware without GraphQL Yoga?
  </h3>
</div>
<p>Yes. Nevertheless, we encourage you to use it in combination with Yoga. Combining the power of <code>middlewares</code> that GraphQL Middleware offers, with <code>documentMiddleware</code> which Yoga exposes, gives you unparalleled control over the execution of your queries.</p>
<div class="pilwrap" id="how-does-graphql-middleware-compare-to-directives">
  <h3>
    <a href="#how-does-graphql-middleware-compare-to-directives" name="how-does-graphql-middleware-compare-to-directives" class="pilcrow"></a>
How does GraphQL Middleware compare to <code>directives</code>?
  </h3>
</div>
<p>GraphQL Middleware and <code>directives</code> tackle the same problem in a completely different way. GraphQL Middleware allows you to implement all your middleware logic in your code, whereas directives encourage you to mix schema with your functionality.</p>
<div class="pilwrap" id="should-i-modify-the-context-using-graphql-middleware">
  <h3>
    <a href="#should-i-modify-the-context-using-graphql-middleware" name="should-i-modify-the-context-using-graphql-middleware" class="pilcrow"></a>
Should I modify the context using GraphQL Middleware?
  </h3>
</div>
<p>GraphQL Middleware allows you to modify the context of your resolvers, but we encourage you to use GraphQL Yoga's <code>documentMiddleware</code> for this functionality instead.</p>
<div class="pilwrap" id="help-and-community">
  <h2>
    <a href="#help-and-community" name="help-and-community" class="pilcrow"></a>
Help &amp; Community <a href="https://slack.prisma.io"><img src="https://slack.prisma.io/badge.svg" alt="Slack Status"></a>
  </h2>
</div>
<p>Join our <a href="http://slack.prisma.io/">Slack community</a> if you run into issues or have questions. We love talking to you!</p>
<p align="center"><a href="https://oss.prisma.io"><img src="https://imgur.com/IMU2ERq.png" alt="Prisma" height="170px"></a></p>
</div>
  </div>
</body>
</html>
