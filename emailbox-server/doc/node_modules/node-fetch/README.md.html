<!DOCTYPE html>
<html>
<head>
  <title>README.md</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="../../doc-style.css" />
  <script src="../../doc-filelist.js"></script>
  <script>
    var relativeDir = "../../";
    var thisFile = "node_modules\\node-fetch\\README.md";
    var defaultSidebar = true;
  </script>
  <script src="../../doc-script.js"></script>

</head>
<body>
  <div id="sidebar_wrapper">
    <div id="sidebar_switch">
      <span class="tree">Files</span>
      <span class="headings">Headings</span>
    </div>
    <div id="tree"></div>
    <div id="headings">

      <div class="heading h1">
        <a href="#node-fetch">node-fetch</a>
      </div>

      <div class="heading h2">
        <a href="#motivation">Motivation</a>
      </div>

      <div class="heading h2">
        <a href="#features">Features</a>
      </div>

      <div class="heading h2">
        <a href="#difference-from-client-side-fetch">Difference from client-side fetch</a>
      </div>

      <div class="heading h2">
        <a href="#install">Install</a>
      </div>

      <div class="heading h2">
        <a href="#usage">Usage</a>
      </div>

      <div class="heading h2">
        <a href="#api">API</a>
      </div>

      <div class="heading h3">
        <a href="#fetch-url-options">fetch(url[, options])</a>
      </div>

      <div class="heading h4">
        <a href="#options">Options</a>
      </div>

      <div class="heading h5">
        <a href="#default-headers">Default Headers</a>
      </div>

      <div class="heading h3">
        <a href="#class-request">Class: Request</a>
      </div>

      <div class="heading h4">
        <a href="#new-request-input-options">new Request(input[, options])</a>
      </div>

      <div class="heading h3">
        <a href="#class-response">Class: Response</a>
      </div>

      <div class="heading h4">
        <a href="#new-response-body-options">new Response([body[, options]])</a>
      </div>

      <div class="heading h4">
        <a href="#response.ok">response.ok</a>
      </div>

      <div class="heading h3">
        <a href="#class-headers">Class: Headers</a>
      </div>

      <div class="heading h4">
        <a href="#new-headers-init">new Headers([init])</a>
      </div>

      <div class="heading h3">
        <a href="#interface-body">Interface: Body</a>
      </div>

      <div class="heading h4">
        <a href="#body.body">body.body</a>
      </div>

      <div class="heading h4">
        <a href="#body.bodyused">body.bodyUsed</a>
      </div>

      <div class="heading h4">
        <a href="#body.arraybuffer">body.arrayBuffer()</a>
      </div>

      <div class="heading h4">
        <a href="#body.blob">body.blob()</a>
      </div>

      <div class="heading h4">
        <a href="#body.json">body.json()</a>
      </div>

      <div class="heading h4">
        <a href="#body.text">body.text()</a>
      </div>

      <div class="heading h4">
        <a href="#body.buffer">body.buffer()</a>
      </div>

      <div class="heading h4">
        <a href="#body.textconverted">body.textConverted()</a>
      </div>

      <div class="heading h3">
        <a href="#class-fetcherror">Class: FetchError</a>
      </div>

      <div class="heading h2">
        <a href="#license">License</a>
      </div>

      <div class="heading h2">
        <a href="#acknowledgement">Acknowledgement</a>
      </div>

    </div>
  </div>
  <div id="sidebar-toggle"></div>
  <div id="container">
    <div class="docs markdown"><div class="pilwrap" id="node-fetch">
  <h1>
    <a href="#node-fetch" name="node-fetch" class="pilcrow"></a>
node-fetch
  </h1>
</div>
<p><a href="https://www.npmjs.com/package/node-fetch"><img src="https://img.shields.io/npm/v/node-fetch.svg?style=flat-square" alt="npm stable version"></a>
<a href="https://www.npmjs.com/package/node-fetch"><img src="https://img.shields.io/npm/v/node-fetch/next.svg?style=flat-square" alt="npm next version"></a>
<a href="https://travis-ci.org/bitinn/node-fetch"><img src="https://img.shields.io/travis/bitinn/node-fetch.svg?style=flat-square" alt="build status"></a>
<a href="https://codecov.io/gh/bitinn/node-fetch"><img src="https://img.shields.io/codecov/c/github/bitinn/node-fetch.svg?style=flat-square" alt="coverage status"></a></p>
<p>A light-weight module that brings <code>window.fetch</code> to Node.js</p>
<div class="pilwrap" id="motivation">
  <h2>
    <a href="#motivation" name="motivation" class="pilcrow"></a>
Motivation
  </h2>
</div>
<p>Instead of implementing <code>XMLHttpRequest</code> in Node.js to run browser-specific <a href="https://github.com/github/fetch">Fetch polyfill</a>, why not go from native <code>http</code> to <code>fetch</code> API directly? Hence <code>node-fetch</code>, minimal code for a <code>window.fetch</code> compatible API on Node.js runtime.</p>
<p>See Matt Andrews' <a href="https://github.com/matthew-andrews/isomorphic-fetch">isomorphic-fetch</a> or Leonardo Quixada's <a href="https://github.com/lquixada/cross-fetch">cross-fetch</a> for isomorphic usage (exports <code>node-fetch</code> for server-side, <code>whatwg-fetch</code> for client-side).</p>
<div class="pilwrap" id="features">
  <h2>
    <a href="#features" name="features" class="pilcrow"></a>
Features
  </h2>
</div>
<ul>
<li>Stay consistent with <code>window.fetch</code> API.</li>
<li>Make conscious trade-off when following <a href="https://fetch.spec.whatwg.org/">whatwg fetch spec</a> and <a href="https://streams.spec.whatwg.org/">stream spec</a> implementation details, document known difference.</li>
<li>Use native promise, but allow substituting it with [insert your favorite promise library].</li>
<li>Use native stream for body, on both request and response.</li>
<li>Decode content encoding (gzip/deflate) properly, convert <code>res.text()</code> output to UTF-8 optionally.</li>
<li>Useful extensions such as timeout, redirect limit, response size limit, <a href="https://github.com/bitinn/node-fetch/blob/master/ERROR-HANDLING.md">explicit errors</a> for troubleshooting.</li>
</ul>
<div class="pilwrap" id="difference-from-client-side-fetch">
  <h2>
    <a href="#difference-from-client-side-fetch" name="difference-from-client-side-fetch" class="pilcrow"></a>
Difference from client-side fetch
  </h2>
</div>
<ul>
<li>See <a href="https://github.com/bitinn/node-fetch/blob/master/LIMITS.md">Known Differences</a> for details.</li>
<li>If you happen to use a missing feature that <code>window.fetch</code> offers, feel free to open an issue.</li>
<li>Pull requests are welcomed too!</li>
</ul>
<div class="pilwrap" id="install">
  <h2>
    <a href="#install" name="install" class="pilcrow"></a>
Install
  </h2>
</div>
<p>Stable release (<code>2.x</code>)</p>
<pre><code class="sh">$ npm install node-fetch --save
</code></pre>
<div class="pilwrap" id="usage">
  <h2>
    <a href="#usage" name="usage" class="pilcrow"></a>
Usage
  </h2>
</div>
<p>Note that documentation below is up-to-date with <code>2.x</code> releases, <a href="https://github.com/bitinn/node-fetch/blob/1.x/README.md">see <code>1.x</code> readme</a>, <a href="https://github.com/bitinn/node-fetch/blob/1.x/CHANGELOG.md">changelog</a> and <a href="https://github.com/bitinn/node-fetch/blob/master/UPGRADE-GUIDE.md">2.x upgrade guide</a> if you want to find out the difference.</p>
<pre><code class="javascript"><span class="hljs-keyword">import</span> fetch <span class="hljs-keyword">from</span> <span class="hljs-string">'node-fetch'</span>;
<span class="hljs-comment">// or</span>
<span class="hljs-comment">// const fetch = require('node-fetch');</span>

<span class="hljs-comment">// if you are using your own Promise library, set it through fetch.Promise. Eg.</span>

<span class="hljs-comment">// import Bluebird from 'bluebird';</span>
<span class="hljs-comment">// fetch.Promise = Bluebird;</span>

<span class="hljs-comment">// plain text or html</span>

fetch(<span class="hljs-string">'https://github.com/'</span>)
	.then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.text())
	.then(<span class="hljs-function"><span class="hljs-params">body</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(body));

<span class="hljs-comment">// json</span>

fetch(<span class="hljs-string">'https://api.github.com/users/github'</span>)
	.then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.json())
	.then(<span class="hljs-function"><span class="hljs-params">json</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(json));

<span class="hljs-comment">// catching network error</span>
<span class="hljs-comment">// 3xx-5xx responses are NOT network errors, and should be handled in then()</span>
<span class="hljs-comment">// you only need one catch() at the end of your promise chain</span>

fetch(<span class="hljs-string">'http://domain.invalid/'</span>)
	.catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-built_in">console</span>.error(err));

<span class="hljs-comment">// stream</span>
<span class="hljs-comment">// the node.js way is to use stream when possible</span>

fetch(<span class="hljs-string">'https://assets-cdn.github.com/images/modules/logos_page/Octocat.png'</span>)
	.then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> {
		<span class="hljs-keyword">const</span> dest = fs.createWriteStream(<span class="hljs-string">'./octocat.png'</span>);
		res.body.pipe(dest);
	});

<span class="hljs-comment">// buffer</span>
<span class="hljs-comment">// if you prefer to cache binary data in full, use buffer()</span>
<span class="hljs-comment">// note that buffer() is a node-fetch only API</span>

<span class="hljs-keyword">import</span> fileType <span class="hljs-keyword">from</span> <span class="hljs-string">'file-type'</span>;

fetch(<span class="hljs-string">'https://assets-cdn.github.com/images/modules/logos_page/Octocat.png'</span>)
	.then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.buffer())
	.then(<span class="hljs-function"><span class="hljs-params">buffer</span> =&gt;</span> fileType(buffer))
	.then(<span class="hljs-function"><span class="hljs-params">type</span> =&gt;</span> { <span class="hljs-comment">/* ... */</span> });

<span class="hljs-comment">// meta</span>

fetch(<span class="hljs-string">'https://github.com/'</span>)
	.then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> {
		<span class="hljs-built_in">console</span>.log(res.ok);
		<span class="hljs-built_in">console</span>.log(res.status);
		<span class="hljs-built_in">console</span>.log(res.statusText);
		<span class="hljs-built_in">console</span>.log(res.headers.raw());
		<span class="hljs-built_in">console</span>.log(res.headers.get(<span class="hljs-string">'content-type'</span>));
	});

<span class="hljs-comment">// post</span>

fetch(<span class="hljs-string">'http://httpbin.org/post'</span>, { <span class="hljs-attr">method</span>: <span class="hljs-string">'POST'</span>, <span class="hljs-attr">body</span>: <span class="hljs-string">'a=1'</span> })
	.then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.json())
	.then(<span class="hljs-function"><span class="hljs-params">json</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(json));

<span class="hljs-comment">// post with stream from file</span>

<span class="hljs-keyword">import</span> { createReadStream } <span class="hljs-keyword">from</span> <span class="hljs-string">'fs'</span>;

<span class="hljs-keyword">const</span> stream = createReadStream(<span class="hljs-string">'input.txt'</span>);
fetch(<span class="hljs-string">'http://httpbin.org/post'</span>, { <span class="hljs-attr">method</span>: <span class="hljs-string">'POST'</span>, <span class="hljs-attr">body</span>: stream })
	.then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.json())
	.then(<span class="hljs-function"><span class="hljs-params">json</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(json));

<span class="hljs-comment">// post with JSON</span>

<span class="hljs-keyword">var</span> body = { <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> };
fetch(<span class="hljs-string">'http://httpbin.org/post'</span>, { 
	<span class="hljs-attr">method</span>: <span class="hljs-string">'POST'</span>,
	<span class="hljs-attr">body</span>:    <span class="hljs-built_in">JSON</span>.stringify(body),
	<span class="hljs-attr">headers</span>: { <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json'</span> },
})
	.then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.json())
	.then(<span class="hljs-function"><span class="hljs-params">json</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(json));

<span class="hljs-comment">// post form parameters (x-www-form-urlencoded)</span>

<span class="hljs-keyword">import</span> { URLSearchParams } <span class="hljs-keyword">from</span> <span class="hljs-string">'url'</span>;

<span class="hljs-keyword">const</span> params = <span class="hljs-keyword">new</span> URLSearchParams();
params.append(<span class="hljs-string">'a'</span>, <span class="hljs-number">1</span>);
fetch(<span class="hljs-string">'http://httpbin.org/post'</span>, { <span class="hljs-attr">method</span>: <span class="hljs-string">'POST'</span>, <span class="hljs-attr">body</span>: params })
	.then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.json())
	.then(<span class="hljs-function"><span class="hljs-params">json</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(json));

<span class="hljs-comment">// post with form-data (detect multipart)</span>

<span class="hljs-keyword">import</span> FormData <span class="hljs-keyword">from</span> <span class="hljs-string">'form-data'</span>;

<span class="hljs-keyword">const</span> form = <span class="hljs-keyword">new</span> FormData();
form.append(<span class="hljs-string">'a'</span>, <span class="hljs-number">1</span>);
fetch(<span class="hljs-string">'http://httpbin.org/post'</span>, { <span class="hljs-attr">method</span>: <span class="hljs-string">'POST'</span>, <span class="hljs-attr">body</span>: form })
	.then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.json())
	.then(<span class="hljs-function"><span class="hljs-params">json</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(json));

<span class="hljs-comment">// post with form-data (custom headers)</span>
<span class="hljs-comment">// note that getHeaders() is non-standard API</span>

<span class="hljs-keyword">import</span> FormData <span class="hljs-keyword">from</span> <span class="hljs-string">'form-data'</span>;

<span class="hljs-keyword">const</span> form = <span class="hljs-keyword">new</span> FormData();
form.append(<span class="hljs-string">'a'</span>, <span class="hljs-number">1</span>);
fetch(<span class="hljs-string">'http://httpbin.org/post'</span>, { <span class="hljs-attr">method</span>: <span class="hljs-string">'POST'</span>, <span class="hljs-attr">body</span>: form, <span class="hljs-attr">headers</span>: form.getHeaders() })
	.then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.json())
	.then(<span class="hljs-function"><span class="hljs-params">json</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(json));

<span class="hljs-comment">// node 7+ with async function</span>

(<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
	<span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">'https://api.github.com/users/github'</span>);
	<span class="hljs-keyword">const</span> json = <span class="hljs-keyword">await</span> res.json();
	<span class="hljs-built_in">console</span>.log(json);
})();
</code></pre>
<p>See <a href="https://github.com/bitinn/node-fetch/blob/master/test/test.js">test cases</a> for more examples.</p>
<div class="pilwrap" id="api">
  <h2>
    <a href="#api" name="api" class="pilcrow"></a>
API
  </h2>
</div>
<div class="pilwrap" id="fetch-url-options">
  <h3>
    <a href="#fetch-url-options" name="fetch-url-options" class="pilcrow"></a>
fetch(url[, options])
  </h3>
</div>
<ul>
<li><code>url</code> A string representing the URL for fetching</li>
<li><code>options</code> <a href="#fetch-options.html">Options</a> for the HTTP(S) request</li>
<li>Returns: <code>Promise&lt;<a href="#class-response.html">Response</a>&gt;</code></li>
</ul>
<p>Perform an HTTP(S) fetch.</p>
<p><code>url</code> should be an absolute url, such as <code>http://example.com/</code>. A path-relative URL (<code>/file/under/root</code>) or protocol-relative URL (<code>//can-be-http-or-https.com/</code>) will result in a rejected promise.</p>
<p><a id="fetch-options"></a></p>
<div class="pilwrap" id="options">
  <h4>
    <a href="#options" name="options" class="pilcrow"></a>
Options
  </h4>
</div>
<p>The default values are shown after each option key.</p>
<pre><code class="js">{
	<span class="hljs-comment">// These properties are part of the Fetch Standard</span>
	method: <span class="hljs-string">'GET'</span>,
	<span class="hljs-attr">headers</span>: {},        <span class="hljs-comment">// request headers. format is the identical to that accepted by the Headers constructor (see below)</span>
	body: <span class="hljs-literal">null</span>,         <span class="hljs-comment">// request body. can be null, a string, a Buffer, a Blob, or a Node.js Readable stream</span>
	redirect: <span class="hljs-string">'follow'</span>, <span class="hljs-comment">// set to `manual` to extract redirect headers, `error` to reject redirect</span>

	<span class="hljs-comment">// The following properties are node-fetch extensions</span>
	follow: <span class="hljs-number">20</span>,         <span class="hljs-comment">// maximum redirect count. 0 to not follow redirect</span>
	timeout: <span class="hljs-number">0</span>,         <span class="hljs-comment">// req/res timeout in ms, it resets on redirect. 0 to disable (OS limit applies)</span>
	compress: <span class="hljs-literal">true</span>,     <span class="hljs-comment">// support gzip/deflate content encoding. false to disable</span>
	size: <span class="hljs-number">0</span>,            <span class="hljs-comment">// maximum response body size in bytes. 0 to disable</span>
	agent: <span class="hljs-literal">null</span>         <span class="hljs-comment">// http(s).Agent instance, allows custom proxy, certificate etc.</span>
}
</code></pre>
<div class="pilwrap" id="default-headers">
  <h5>
    <a href="#default-headers" name="default-headers" class="pilcrow"></a>
Default Headers
  </h5>
</div>
<p>If no values are set, the following request headers will be sent automatically:</p>
<table>
<thead>
<tr>
<th>Header</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Accept-Encoding</code></td>
<td><code>gzip,deflate</code> <em>(when <code>options.compress === true</code>)</em></td>
</tr>
<tr>
<td><code>Accept</code></td>
<td><code>*/*</code></td>
</tr>
<tr>
<td><code>Connection</code></td>
<td><code>close</code> <em>(when no <code>options.agent</code> is present)</em></td>
</tr>
<tr>
<td><code>Content-Length</code></td>
<td><em>(automatically calculated, if possible)</em></td>
</tr>
<tr>
<td><code>User-Agent</code></td>
<td><code>node-fetch/1.0 (+https://github.com/bitinn/node-fetch)</code></td>
</tr>
</tbody>
</table>
<p><a id="class-request"></a></p>
<div class="pilwrap" id="class-request">
  <h3>
    <a href="#class-request" name="class-request" class="pilcrow"></a>
Class: Request
  </h3>
</div>
<p>An HTTP(S) request containing information about URL, method, headers, and the body. This class implements the <a href="#iface-body.html">Body</a> interface.</p>
<p>Due to the nature of Node.js, the following properties are not implemented at this moment:</p>
<ul>
<li><code>type</code></li>
<li><code>destination</code></li>
<li><code>referrer</code></li>
<li><code>referrerPolicy</code></li>
<li><code>mode</code></li>
<li><code>credentials</code></li>
<li><code>cache</code></li>
<li><code>integrity</code></li>
<li><code>keepalive</code></li>
</ul>
<p>The following node-fetch extension properties are provided:</p>
<ul>
<li><code>follow</code></li>
<li><code>compress</code></li>
<li><code>counter</code></li>
<li><code>agent</code></li>
</ul>
<p>See <a href="#fetch-options.html">options</a> for exact meaning of these extensions.</p>
<div class="pilwrap" id="new-request-input-options">
  <h4>
    <a href="#new-request-input-options" name="new-request-input-options" class="pilcrow"></a>
new Request(input[, options])
  </h4>
</div>
<p><small><em>(spec-compliant)</em></small></p>
<ul>
<li><code>input</code> A string representing a URL, or another <code>Request</code> (which will be cloned)</li>
<li><code>options</code> [Options][#fetch-options] for the HTTP(S) request</li>
</ul>
<p>Constructs a new <code>Request</code> object. The constructor is identical to that in the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Request/Request">browser</a>.</p>
<p>In most cases, directly <code>fetch(url, options)</code> is simpler than creating a <code>Request</code> object.</p>
<p><a id="class-response"></a></p>
<div class="pilwrap" id="class-response">
  <h3>
    <a href="#class-response" name="class-response" class="pilcrow"></a>
Class: Response
  </h3>
</div>
<p>An HTTP(S) response. This class implements the <a href="#iface-body.html">Body</a> interface.</p>
<p>The following properties are not implemented in node-fetch at this moment:</p>
<ul>
<li><code>Response.error()</code></li>
<li><code>Response.redirect()</code></li>
<li><code>type</code></li>
<li><code>redirected</code></li>
<li><code>trailer</code></li>
</ul>
<div class="pilwrap" id="new-response-body-options">
  <h4>
    <a href="#new-response-body-options" name="new-response-body-options" class="pilcrow"></a>
new Response([body[, options]])
  </h4>
</div>
<p><small><em>(spec-compliant)</em></small></p>
<ul>
<li><code>body</code> A string or <a href="https://nodejs.org/api/stream.html#stream_readable_streams">Readable stream</a></li>
<li><code>options</code> A <a href="https://fetch.spec.whatwg.org/#responseinit"><code>ResponseInit</code></a> options dictionary</li>
</ul>
<p>Constructs a new <code>Response</code> object. The constructor is identical to that in the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Response/Response">browser</a>.</p>
<p>Because Node.js does not implement service workers (for which this class was designed), one rarely has to construct a <code>Response</code> directly.</p>
<div class="pilwrap" id="response.ok">
  <h4>
    <a href="#response.ok" name="response.ok" class="pilcrow"></a>
response.ok
  </h4>
</div>
<p>Convenience property representing if the request ended normally. Will evaluate to true if the response status was greater than or equal to 200 but smaller than 300.</p>
<p><a id="class-headers"></a></p>
<div class="pilwrap" id="class-headers">
  <h3>
    <a href="#class-headers" name="class-headers" class="pilcrow"></a>
Class: Headers
  </h3>
</div>
<p>This class allows manipulating and iterating over a set of HTTP headers. All methods specified in the <a href="https://fetch.spec.whatwg.org/">Fetch Standard</a> are implemented.</p>
<div class="pilwrap" id="new-headers-init">
  <h4>
    <a href="#new-headers-init" name="new-headers-init" class="pilcrow"></a>
new Headers([init])
  </h4>
</div>
<p><small><em>(spec-compliant)</em></small></p>
<ul>
<li><code>init</code> Optional argument to pre-fill the <code>Headers</code> object</li>
</ul>
<p>Construct a new <code>Headers</code> object. <code>init</code> can be either <code>null</code>, a <code>Headers</code> object, an key-value map object, or any iterable object.</p>
<pre><code class="js"><span class="hljs-comment">// Example adapted from https://fetch.spec.whatwg.org/#example-headers-class</span>

<span class="hljs-keyword">const</span> meta = {
  <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'text/xml'</span>,
  <span class="hljs-string">'Breaking-Bad'</span>: <span class="hljs-string">'&lt;3'</span>
};
<span class="hljs-keyword">const</span> headers = <span class="hljs-keyword">new</span> Headers(meta);

<span class="hljs-comment">// The above is equivalent to</span>
<span class="hljs-keyword">const</span> meta = [
  [ <span class="hljs-string">'Content-Type'</span>, <span class="hljs-string">'text/xml'</span> ],
  [ <span class="hljs-string">'Breaking-Bad'</span>, <span class="hljs-string">'&lt;3'</span> ]
];
<span class="hljs-keyword">const</span> headers = <span class="hljs-keyword">new</span> Headers(meta);

<span class="hljs-comment">// You can in fact use any iterable objects, like a Map or even another Headers</span>
<span class="hljs-keyword">const</span> meta = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
meta.set(<span class="hljs-string">'Content-Type'</span>, <span class="hljs-string">'text/xml'</span>);
meta.set(<span class="hljs-string">'Breaking-Bad'</span>, <span class="hljs-string">'&lt;3'</span>);
<span class="hljs-keyword">const</span> headers = <span class="hljs-keyword">new</span> Headers(meta);
<span class="hljs-keyword">const</span> copyOfHeaders = <span class="hljs-keyword">new</span> Headers(headers);
</code></pre>
<p><a id="iface-body"></a></p>
<div class="pilwrap" id="interface-body">
  <h3>
    <a href="#interface-body" name="interface-body" class="pilcrow"></a>
Interface: Body
  </h3>
</div>
<p><code>Body</code> is an abstract interface with methods that are applicable to both <code>Request</code> and <code>Response</code> classes.</p>
<p>The following methods are not yet implemented in node-fetch at this moment:</p>
<ul>
<li><code>formData()</code></li>
</ul>
<div class="pilwrap" id="body.body">
  <h4>
    <a href="#body.body" name="body.body" class="pilcrow"></a>
body.body
  </h4>
</div>
<p><small><em>(deviation from spec)</em></small></p>
<ul>
<li>Node.js <a href="https://nodejs.org/api/stream.html#stream_readable_streams"><code>Readable</code> stream</a></li>
</ul>
<p>The data encapsulated in the <code>Body</code> object. Note that while the <a href="https://fetch.spec.whatwg.org/">Fetch Standard</a> requires the property to always be a WHATWG <code>ReadableStream</code>, in node-fetch it is a Node.js <a href="https://nodejs.org/api/stream.html#stream_readable_streams"><code>Readable</code> stream</a>.</p>
<div class="pilwrap" id="body.bodyused">
  <h4>
    <a href="#body.bodyused" name="body.bodyused" class="pilcrow"></a>
body.bodyUsed
  </h4>
</div>
<p><small><em>(spec-compliant)</em></small></p>
<ul>
<li><code>Boolean</code></li>
</ul>
<p>A boolean property for if this body has been consumed. Per spec, a consumed body cannot be used again.</p>
<div class="pilwrap" id="body.arraybuffer">
  <h4>
    <a href="#body.arraybuffer" name="body.arraybuffer" class="pilcrow"></a>
body.arrayBuffer()
  </h4>
</div>
<div class="pilwrap" id="body.blob">
  <h4>
    <a href="#body.blob" name="body.blob" class="pilcrow"></a>
body.blob()
  </h4>
</div>
<div class="pilwrap" id="body.json">
  <h4>
    <a href="#body.json" name="body.json" class="pilcrow"></a>
body.json()
  </h4>
</div>
<div class="pilwrap" id="body.text">
  <h4>
    <a href="#body.text" name="body.text" class="pilcrow"></a>
body.text()
  </h4>
</div>
<p><small><em>(spec-compliant)</em></small></p>
<ul>
<li>Returns: <code>Promise</code></li>
</ul>
<p>Consume the body and return a promise that will resolve to one of these formats.</p>
<div class="pilwrap" id="body.buffer">
  <h4>
    <a href="#body.buffer" name="body.buffer" class="pilcrow"></a>
body.buffer()
  </h4>
</div>
<p><small><em>(node-fetch extension)</em></small></p>
<ul>
<li>Returns: <code>Promise&lt;Buffer&gt;</code></li>
</ul>
<p>Consume the body and return a promise that will resolve to a Buffer.</p>
<div class="pilwrap" id="body.textconverted">
  <h4>
    <a href="#body.textconverted" name="body.textconverted" class="pilcrow"></a>
body.textConverted()
  </h4>
</div>
<p><small><em>(node-fetch extension)</em></small></p>
<ul>
<li>Returns: <code>Promise&lt;String&gt;</code></li>
</ul>
<p>Identical to <code>body.text()</code>, except instead of always converting to UTF-8, encoding sniffing will be performed and text converted to UTF-8, if possible.</p>
<p><a id="class-fetcherror"></a></p>
<div class="pilwrap" id="class-fetcherror">
  <h3>
    <a href="#class-fetcherror" name="class-fetcherror" class="pilcrow"></a>
Class: FetchError
  </h3>
</div>
<p><small><em>(node-fetch extension)</em></small></p>
<p>An operational error in the fetching process. See <a href="https://github.com/bitinn/node-fetch/blob/master/ERROR-HANDLING.md">ERROR-HANDLING.md</a> for more info.</p>
<div class="pilwrap" id="license">
  <h2>
    <a href="#license" name="license" class="pilcrow"></a>
License
  </h2>
</div>
<p>MIT</p>
<div class="pilwrap" id="acknowledgement">
  <h2>
    <a href="#acknowledgement" name="acknowledgement" class="pilcrow"></a>
Acknowledgement
  </h2>
</div>
<p>Thanks to <a href="https://github.com/github/fetch">github/fetch</a> for providing a solid implementation reference.</p>
</div>
  </div>
</body>
</html>
